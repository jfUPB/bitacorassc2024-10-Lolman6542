# Bitácora de aprendizaje

## ¿Cómo voy?

- [Sí] Terminé la fase de investigación. 
- [ ] Terminé la fase de aplicación.
- [ ] Terminé la fase de compartir.

## Compartir

### ¿Manejé bajo control de versión el código de mi aplicación?
### Muestro y explico mi implementación del encapsulamiento.
### Muestro y explico mi implementación de la herencia.
### Muestro y explico mi implementación del polimorfismo.
### Muestra cómo probaste la funcionalidad de cada característica de la aplicación,
### Muestra cómo probaste la integración de cada característica con las anteriores.

## Consejos para el uso efectivo de la bitácora

* Preparación al inicio de la micro-sesión 1: establece un objetivo claro de la sesión para maximizar el tiempo de trabajo efectivo.
* Concisión: sé breve pero significativo en tus respuestas para ajustarte al tiempo de reflexión de 4 minutos.
* Pausas activas: usa las pausas de 1 minutos para realmente desconectar, estirar y descansar los ojos; esto ayuda a mantener la energía y la concentración.
* Reflexión profunda al final de la mimcro-sesión 4: usa parte del tiempo para una reflexión más profunda y para planificar, asegurándote de cerrar la sesión
  con una nota productiva y prepararte para lo que sigue.

## Semana 10

### Sesión 1

#### Micro-sesión 1 (25 minutos)

**Planeación:**

1. ¿Qué voy a trabajar hoy?

   R/= Lo que se hara hoy es aprender o almmenos recordar conceptos de de Programacion orientada a objetos (POO)
   atravess del lenguage C que curiosamente no lo soporta, pero puede implementarse. Mas que todo revisar estos
   temas para largo, durante su desarrollo en la unidad. y en concreto el Refactoring.

2. ¿Cuál es mi objetivo principal para esta sesión?

   R/= Acordarme de los temas de POO y entender que es el Refactoring.

**Trabajo en concentración**

**Meta-aprendizaje:**

3. ¿Qué he logrado en esta micro-sesión de trabajo?

   R/= Un resumen de lo que trata que es POO. 
    La Programación Orientada a Objetos (POO) es un paradigma de programación que se basa en el concepto de "objetos".
    Estos objetos representan entidades del mundo real y tienen características (atributos) y comportamientos (métodos) asociados.
    La POO se centra en organizar el código de manera que las operaciones se realicen sobre objetos individuales, 
    lo que facilita la modularidad, la reutilización y la mantenibilidad del código., un resumen de lo que trata que es POO.

4. ¿Con qué dificultades me encontré y cómo las abordé?

   R/= Hasta el momento ninguno dado que ahora mismo estoy es revisando los conceptos
   y fueron abordados con ayuda del ChatGPT.

5. ¿Estoy más cerca de alcanzar el objetivo de la sesión? ¿Qué falta por hacer?

    R/= Si voy bien, debo de ver los conceptos claves de POO.

6. ¿Qué he aprendido o reforzado en esta micro-sesión? 
    
   R/= Poo se encarga de organizar los codigos de manera que las operaciones 
   se realicen sobre objetos individuales, facilitando la modularidad, 
   reutilizacion y mantebilidad de codigo, optimizandolo al maximo.

#### Micro-sesión 2 (25 minutos)

**Trabajo en concentración**

**Meta-aprendizaje:**

1. ¿Qué he logrado en esta micro-sesión de trabajo?

  R/= Encontrar de que es lo que trata los conceptos de Clases y Obejetos junto Encapsulamiento.

Clases y Objetos: 
Una clase es una plantilla o modelo para crear objetos. Define los atributos 
y métodos que tendrán los objetos de esa clase. 
Por ejemplo, una clase "Coche" puede tener atributos como color, marca, modelo, y métodos como acelerar, frenar, etc.
Un objeto es una instancia de una clase específica, es decir, una representación concreta de esa clase.

Encapsulamiento: 
Es el principio que consiste en ocultar los detalles internos de un objeto y exponer solo los métodos necesarios para interactuar con él.
Esto se logra mediante el uso de modificadores de acceso como public, private y protected 
en la definición de atributos y métodos de una clase.


2. ¿Con qué dificultades me encontré y cómo las abordé?

  R/= Hasta el momento ninguno dado que ahora mismo estoy es revisando los conceptos
   y fueron abordados con ayuda del ChatGPT.
    
3. ¿Estoy más cerca de alcanzar el objetivo de la sesión? ¿Qué falta por hacer?

  R/= Me encuentro mas cerca solo debo de seguir con los otros que falta por
  encontrar y entender.

4. ¿Qué he aprendido o reforzado en esta micro-sesión? 

  R/= En general, Los objetos son una represaticon de una clase y estas Clases son las 
  caracteristicas y atributos que poseen. Mientras que el encapsulamiento trata de ocultar
  detalles de los objetos mediante comandos que pueden usarse en las clases.

#### Micro-sesión 3 (25 minutos)

**Trabajo en concentración**

Herencia:
Permite crear una nueva clase (subclase o clase derivada) basada en una clase existente (superclase o clase base).
La subclase hereda los atributos y métodos de la superclase, lo que fomenta la reutilización de código y la jerarquía de clases. 
Por ejemplo, una subclase "SUV" podría heredar de la clase "Coche".

Polimorfismo:
Es la capacidad de un objeto para comportarse de diferentes formas según el contexto. Puede manifestarse de varias maneras,
como el sobrecargado de métodos (mismos nombres de métodos pero con diferentes parámetros) y la sobreescritura de métodos 
(métodos con el mismo nombre y firma en la clase base y sus subclases, pero con implementaciones diferentes).

**Meta-aprendizaje:**

1. ¿Qué he logrado en esta micro-sesión de trabajo?  

  R/= Sí ya encontre los conceptos que faltaban, de lo que es Herencia y Polimorfismo en resumen.

Herencia:
Permite crear una nueva clase (subclase o clase derivada) basada en una clase existente (superclase o clase base).
La subclase hereda los atributos y métodos de la superclase, lo que fomenta la reutilización de código y la jerarquía de clases. 
Por ejemplo, una subclase "SUV" podría heredar de la clase "Coche".

Polimorfismo:
Es la capacidad de un objeto para comportarse de diferentes formas según el contexto. Puede manifestarse de varias maneras,
como el sobrecargado de métodos (mismos nombres de métodos pero con diferentes parámetros) y la sobreescritura de métodos 
(métodos con el mismo nombre y firma en la clase base y sus subclases, pero con implementaciones diferentes).
  

2. ¿Con qué dificultades me encontré y cómo las abordé?

  R/= Hasta el momento ninguno dado que ahora mismo estoy es revisando los conceptos
    y fueron abordados con ayuda del ChatGPT.
   
4. ¿Estoy más cerca de alcanzar el objetivo de la sesión? ¿Qué falta por hacer?

  R/= En el momento si para cerrar esta sesión, solo faltaria el Refactory como tal.

5. ¿Qué he aprendido o reforzado en esta micro-sesión? 

  R/= Como tal herencia se puede era atributos de una clase, pasarcelas a otra que seria Superclase
  de los que cuales tendria los atributos de dicha clase que hereda y sus propios atributos por ser una nueva.
  Mientras que el polimorfismo al enviar el mismo mensaje desde distintos objetos, cada uno de esos objetos
  pueda responder a ese mensaje  de forma distinta. 

#### Micro-sesión 4. (25 minutos)

**Trabajo en concentración**

**Meta-aprendizaje:**

1. ¿Qué he logrado en esta micro-sesión de trabajo?

  R/= Un resumen de lo que trata el refactoring.
  El refactoring (o refactorización) es una técnica utilizada en programación para mejorar la estructura interna del código
sin cambiar su comportamiento externo. Básicamente, consiste en reorganizar el código para que sea más fácil 
de entender, mantener y modificar en el futuro, sin afectar su funcionalidad.

Algunas de las acciones comunes que se realizan durante el refactoring incluyen la eliminación de código duplicado,
la simplificación de bloques de código complejos, la mejora de nombres de variables y funciones para que sean más descriptivos,
y la reorganización de la estructura del código para que sea más coherente y legible.

2. ¿Con qué dificultades me encontré y cómo las abordé?
   
   R/= Hatas el momento, no me he encontrado ningun problema y lo resolvi con ayuda de chatGPT.
   
3. ¿Estoy más cerca de alcanzar el objetivo de la sesión? ¿Qué falta por hacer?

   R/= Si ya termine de revisar como tal el concepto de POO, por ahora no hay nada que hacer.

4. ¿Qué he aprendido o reforzado en esta micro-sesión?

   R/= Reduce la complejidad, facilita la detección y corrección de errores, y hace que el código sea más fácil
   de mantener y ampliar a medida que evoluciona el proyecto (Perdon si avanze antes).

**Cierre de sesión:**

5. ¿He alcanzado los objetivos planteados al inicio? Si no, ¿por qué y qué puedo mejorar?

R/= Si ya me acorde un poco mas de lo que iba POO y su refactoring, tengo que mejor la distribución del tiempo
y sintetizar mis respuestas.
  
6. ¿Cuáles fueron los desafíos más significativos de hoy y cómo los superé?

R/= Hasta el momento no a habido ningun problema, dado que lo que me dedique en esta sesion era un repaso 
de los conceptos de POO y el refactoring, tal vez lo mas complicado fue el tema refactoring, logre resolver mi dudas del temas
con investigaciones en internet y herramientas como ChatGPT.

7. Basado en el trabajo de hoy, ¿qué insights importantes he ganado?

R/= De que trata el tema de POO y sus conceptos. Por ahora ha sido simple, pero debo de seguir con su fase de experimetación.

8. ¿Cuáles son los pasos siguientes para continuar avanzando en el proyecto?

R/= Ahora mismo debo de seguir solucionando los otros Retos que hay en la fase de investigación, 
debo de poner aprueba o ejecutar los programas de Encapsulamiento con lenguaje C, en el visual.

### Sesión 2

#### Micro-sesión 1 (25 minutos)

**Planeación:**

1. ¿Qué voy a trabajar hoy?

R/= Continuare con los ejercicios de la fase de investigación, mas que todo empezar a ejecutar programas/codigos.

2. ¿Cuál es mi objetivo principal para esta sesión?

R/= Desatrasarme de las bitacoras de esta unidad, y mas que todo seguir continuando con la fase de investigación.
Respondi las siguientes preguntas que planteaba la bitacora:


**Trabajo en concentración**

**Meta-aprendizaje:**

3. ¿Qué he logrado en esta micro-sesión de trabajo?

R/= Me dedique hacer el ejercicio 1 dado que me lo habia saltado en la anterior sesión debido a que me dedique a buscar los conceptos.
- ¿En qué parte del programa se crean objetos?
  Estos se crean fuera de la función principal (main) utilizando el constructor "Shape_ctor". Si se crea un objeto Shape, llamariamos a 
  "Shape_ctor" con un puntero a una variable tipo Shape, pasando las coordenadas X e Y como argumentos.
- ¿En que parte de la memoria estan creados los objetos?
  Se almacenan en un segmento de memoria llamado "Heap", usando un operador malloc dentro del constructor "Shape_ctor", asignado
  de manera dinamica memoria en el heap durante el tiempo de ejecucion del programa.
- ¿Que es un Objeto?
  Es una instacia de una estructura o clase en POO , del cual cada objeto tiene sus propias variables y pueden tener sus 
  propios metodos asociados para manipular esos datos, tambien permiten mdelar entidades del mundo real dentro de un programa de computador y facilita
  la modularidad y reutilizacion de codigo.

![image](https://github.com/jfUPB/bitacorassc2024-10-Lolman6542/assets/127360762/188d84ff-ec28-4ef1-a919-312705b8ac93)


4. ¿Con qué dificultades me encontré y cómo las abordé?

  R/= No me he encontrado ninguna dificultad, aunque me toco usar una plantilla vieja de Pong para que funcionace el codigo.

5. ¿Estoy más cerca de alcanzar el objetivo de la sesión? ¿Qué falta por hacer?

  R/= No, debo de seguir contuniando con la fase de investigacion para seguir reportando en la bitacaro.

6. ¿Qué he aprendido o reforzado en esta micro-sesión? 

  R/= Por ahora esto otra vez reforzando el concepto de encapsulamiento y su implementacion en el programa,
  dado que la sesion pasada me puse a investifar los conceptos primero.

#### Micro-sesión 2 (25 minutos)

**Trabajo en concentración**

**Meta-aprendizaje:**

1. ¿Qué he logrado en esta micro-sesión de trabajo?

  R/= Para el ejercicio 3 hice el ejemplo el cual encapsulamos las propiedades de un rectangulo y un circulo dentro de
  las dentro de las estructuras Rectangle y Circle, respectivamente. Ademas implemente un metodo intersect para verificar   
  si los dos objetos se intersectan entre sí. En el bucle principal del programa dibujamos el rectangulo y el círculo  
  en la ventana de SDL y cambimos el color de la línea que los conecta dependiendo de si se intersectan o no.

2. ¿Con qué dificultades me encontré y cómo las abordé?

R/= Lo mas dificil fue hacer el ejercicio 3 ya que tuve varios errores en el codigo y no me compilaba correctamente,
del resto pude seguir y no se presento otro problema.
  
3. ¿Estoy más cerca de alcanzar el objetivo de la sesión? ¿Qué falta por hacer?

  R/= Aun faltan otros ejercicios de la fase de investiganción por responder...

4. ¿Qué he aprendido o reforzado en esta micro-sesión? 

  R/= Mas que todo en como implementar correctamente el encapsulamiento y fue hecho tomando como fuente el ejercicio 1.

#### Micro-sesión 3 (25 minutos)

**Trabajo en concentración**

**Meta-aprendizaje:**

1. ¿Qué he logrado en esta micro-sesión de trabajo?

  R/= Empece a responder preguntas acerca del ejercio 4 y 5 de lo que es un PLAN o MODELO. Basicamente el profesor 
  nos invita a que antes de que empecemos a programar, hay que pensar todas las cosas queremos diseñar e implementar,
  si a mucho tenerlo en papel. Tambien esta la pregunta del Constructor de una clase y su función, que en Lenguaje C
  utilizando las bibliotecas SDL un constructor de clase es similar, aunque el lenguaje y las bibliotecas puedan imponer
  algunas diferencias en su implementación, dado que no hay un concepto nativo de clases o constructores como lo hay 
  en otros como C++ O Java. Pero puede ser emulado un constructor en C definiendo una función que inicializa una estructura   
  específica con valores iniciales.

2. ¿Con qué dificultades me encontré y cómo las abordé?

  R/= Hasta el momento todo bien, pero talvez sea algo complicado al programarlo.

3. ¿Estoy más cerca de alcanzar el objetivo de la sesión? ¿Qué falta por hacer?

  R/= Aun falta ejercios por en la fase de investigacion, debo de seguir.

4. ¿Qué he aprendido o reforzado en esta micro-sesión? 

  R/= Que es mejor plantearse de lo que se puede y no se puede hacer con un lenguaje de programación,
  tanto conocer nuestros limites como del mismo lenguaje, para asi poder un buen diseño del mismo.


#### Micro-sesión 4. (25 minutos)

**Trabajo en concentración**

**Meta-aprendizaje:**

1. ¿Qué he logrado en esta micro-sesión de trabajo?

  R/= Estando en el ejercicio 6 ¿Cual es el estado y el comportamiento? El estado de un objeto Shape  
  se define por las propiedades X e Y, que representan las coordenas del plano bidimensional.
  Estas propiedades determinan la posición del Objeto en la ventana grafica y el Comportamiento  
  de un un objeto Shape se define por las funciones proporcionadas:  

  - Shape_ctor(Shape * const me, int16_t x, int16_t y): Inicia un objeto Shape con valores especificos para las coordenadas X e Y.
  - Shape_dtor(Shape * const me): Libera la memoria u realiza otras tareas de limpieza cuando un objeto Shape ya no es necesario.
  - Shape_moveby(Shape * const me, int16_t dx, int16_t dy): Permite mover el objeto Shape en la ventana gráfica agregando los  
    desplazamientos dx y dy a sus cooredenadas X e Y, respectivamente.
  - int16_t Shape_getX(Shape const * const me): Esta función devuelve la coordenada x actual del objeto Shape.
  - int16_t Shape_getY(Shape const * const me): Esta función devuelve la coordenada y actual del objeto Shape.


2. ¿Con qué dificultades me encontré y cómo las abordé?

  R/= Creo que debere ponerme en practica para lograr entender bien el concepto, antes de seguir estando perdido
  para su implementacion en lenguage C.

3. ¿Estoy más cerca de alcanzar el objetivo de la sesión? ¿Qué falta por hacer?

  R/= Estoy reforzando de a poco el tema de encapsulamiento, pero debo de seguir investigando para seguir resolviendo
  otros problemas o desafios.

4. ¿Qué he aprendido o reforzado en esta micro-sesión?

  R/= Que la clase llamada Shape, incluyen muchas funciones de las cuales puede crear, destruir, 
  mover y obtener las coordenadas de objetos Shape en un plano bidimensional.

**Cierre de sesión:**

5. ¿He alcanzado los objetivos planteados al inicio? Si no, ¿por qué y qué puedo mejorar?

  R/= se podria decir que sí, reforce una vez mas tema de encapsulamiento. Debo de contuniar con la fase de
  investigación para continuar reforzando y aprendiendo.

6. ¿Cuáles fueron los desafíos más significativos de hoy y cómo los superé?

  R/= Implementar POO en un lenguaje que no lo soportaba nativamente que en este caso es el C,
  pero con ayuda del tema Encapsulamiento, y sus ejercicios e investigación estoy alcanzandolo.

7. Basado en el trabajo de hoy, ¿qué insights importantes he ganado?

  R/= Hasta este momento el como implementar y entender el concepto de encapsulamiento.

8. ¿Cuáles son los pasos siguientes para continuar avanzando en el proyecto?

  R/= Ahora me tocara empezar a entender e implementar la función de la herencia y polimorfismo en lenguaje C para la otra sesión. 

### Sesión 3

#### Micro-sesión 1 (25 minutos)

**Planeación:**

1. ¿Qué voy a trabajar hoy?

  R/= Seguir trabajando en la Bitacora porque estoy muy atrasado.

2. ¿Cuál es mi objetivo principal para esta sesión?

  R/= Estare trabajando los siguientes ejercicios de la fase de investigación, que son herencia para poder implementarlos.

**Trabajo en concentración**

**Meta-aprendizaje:**

3. ¿Qué he logrado en esta micro-sesión de trabajo?

  R/= Salte hacia el ejercicio 9, cual tienes varias preguntas por responder. ¿Como se veria en memoria un
  objeto de la clase Shape? Ocuparía un bloque de memoria contiguo que contiene dos variables de tipo int16_t 
  para las coordenadas X e Y. Estas variables se almacenarían secuencialmente en la memoria, una despúes de la otra,
  dado que no hay ningun otro dato en la clase Shape. Por lo tanto, un objeto de la clase Shape simplemente contendría
  dos valores enteros de 16 bits consecutivos, representado la coordenadas X e Y, respectivamente. En ciertos casos
  el relleno de la estructura debido a la alineación de memoria, pueden afectar como se ve exactamente en la memoria.

  ¿Como se vería en memoria un objeto de la clase Rectangle? Se veria como un bloque contiguo que contiene tres
  variables: dos variables de tipo int16_t para las coordenadas X e Yheredadas de la clase Shape, y una variable de tipo 
  uint16_t para el ancho y otra para la altura del rectángulo. Las variables se almacenarían  secuencialmete en la 
  memoria en el orden en que estan definidas en la estructura Rectangle, siendo primero las coordenadas X e Y
  seguidas del ancho y la altura. Tambien el compilador se encargaria de rellenar para aegurar que las variables estén 
  alineadas correctamente en la memoria.

 
4. ¿Con qué dificultades me encontré y cómo las abordé?

  R/= Ninguna hasta el momento, debo de continuar con el desarrollo de los ejercicios para ver si me topo con una.

5. ¿Estoy más cerca de alcanzar el objetivo de la sesión? ¿Qué falta por hacer?

  R/= Falta mas información acerca de la herencia, para entenderlo. Hay que seguir haciendo los ejercicios.

6. ¿Qué he aprendido o reforzado en esta micro-sesión?

  R/= Ya se como luciria en memoria un objeto de la clase Shape y la clase Rectangle, aun falta mas por hacer. 

#### Micro-sesión 2 (25 minutos)

**Trabajo en concentración**

**Meta-aprendizaje:**

1. ¿Qué he logrado en esta micro-sesión de trabajo?

  R/= Continue con las preguntas del ejercicio de la herencia. ¿Que relación ves entre los dos objetos en terminos de
  en cómo se ven en memoria? Ambs objetos tienen una relación de compooosición. Esto se debe a que la clase
  Rectangle contiene un objeto de la clase Shape como miembro (super), en otras palabras, la estructura de Rectangle
  contendría los datos  de un objeto Shape (es decir, coordenadas X e Y) junto con su propio conjunto de datos (ancho y altura),
  todo en un bloque contiguo. Dando una relación entre un rectángulo y una forma en términos de diseño de software.
  Tambien un Rectangle es un shape debido a que la clase Rectangle hereda todas las propiedades y comportamientos 
  de la clase Shape e incluso puede tener sus propios atributos y comportamientos específicos de un rectángulo.
  Aunque Rectangle contiene un objeto Shape como un miembro, lo que implica una relácion de composición. Llegando a
  decir que un Rectangle tiene un Shape, en vez de ser uno.

2. ¿Con qué dificultades me encontré y cómo las abordé?

  R/= Hasta el momento todo va bien, su implementacion seria lo mas preocupante.

3. ¿Estoy más cerca de alcanzar el objetivo de la sesión? ¿Qué falta por hacer?

  R/= Aun no, debo de ver el polimorfismo, lo que sifnifica que debo de seguir investgando.

4. ¿Qué he aprendido o reforzado en esta micro-sesión? 

  R/=  Tengo claro como las clase Rectangle ereda de la clase Shape en el codigo del ejrcicio de la herencia.

#### Micro-sesión 3 (25 minutos)

**Trabajo en concentración**

**Meta-aprendizaje:**

1. ¿Qué he logrado en esta micro-sesión de trabajo?

  R/= Respondi la ultima pregunta del ejercicio de la herencia ¿Qué está pasando en el siguiente código? (Shape *)r1.
  El código, está realizando una conversión de tipo, convirtiendo un puntero r1 de tipo Rectangle a un puntero de tipo
  shappe. Esto se conoce como "casting" y está indicando al compilador que interprete el puntero r1 como un puntero a un objeto de la clase Shape,
  aunque técnicamente r1 es un puntero a un objeto de la clase Rectangle. Esta conversion es posible debido a la relación de herencia entre Rectangle
  y Shape, donde Rectangle es una subclase de Shape.

2. ¿Con qué dificultades me encontré y cómo las abordé?

  R/= No habia caido en cuenta que esa funcion era un puntero, pero investigando logre responder la pregunta.

3. ¿Estoy más cerca de alcanzar el objetivo de la sesión? ¿Qué falta por hacer?

  R/= Incluso aunque haya avanzado, me falta aun el polimorfismo, entoces debo de avanzar en eso para llegar mi objetivo.

4. ¿Qué he aprendido o reforzado en esta micro-sesión? 

  R/= La herencia es la habilidad de definir una nueva clase basada en clases existentes para reusar y organizar codigo.

#### Micro-sesión 4. (25 minutos)

**Trabajo en concentración**

**Meta-aprendizaje:**

1. ¿Qué he logrado en esta micro-sesión de trabajo?

  R/= Construi el siguiente codigo:

  ``` c
  using System;

// Clase base Shape
public class Shape
{
    public int x;
    public int y;

    // Constructor de Shape
    public Shape(int x, int y)
    {
        this.x = x;
        this.y = y;
    }

    // Método para mover la forma
    public virtual void MoveBy(int dx, int dy)
    {
        x += dx;
        y += dy;
    }

    // Método para obtener la coordenada x
    public int GetX()
    {
        return x;
    }

    // Método para obtener la coordenada y
    public int GetY()
    {
        return y;
    }
}

// Clase derivada Rectangle
public class Rectangle : Shape
{
    public int width;
    public int height;

    // Constructor de Rectangle
    public Rectangle(int x, int y, int width, int height) : base(x, y)
    {
        this.width = width;
        this.height = height;
    }
}

  
  ``` 
  Ahora compararemos esta versión en C# con la implementación original en C:

  Sintaxis: Son diferentes, En C# se utiliza llaves {} para delimitar bloques de código, los puntos y comas ; 
  al final de las declaraciones son obligatorios.

  Constructores: En C# utilizan constructores para inicializar los objetos, lo cual es similar al enfoque en C con las funciones Shape_ctor 
  y Rectangle_ctor. Sin embargo, en C# los contructores se llaman automáticamen al crear un objeto utilizando la palabra clave new.

  Métodos: Los metodos en C# se definen dentro de las clases y pueden ser virtuales, lo que permite la sobrescritura en clases derivadas,
  similar a los métodos en C con as funciones Shape_moveBy, Shape_getX y Shape_getY.

  Herencia: En C#, la herenciase especifica utilizando la palabra clave :, similar a la forma en que se realiza en C con la estructura Rectangle
  que contiene un miembro de tipo Shape. La clase derivada Rectangle hereda los miembros públicos y protegidos de la clase Shape.
  

2. ¿Con qué dificultades me encontré y cómo las abordé?

  R/= Lo mas dificil fue pasar el codigo a otro lenguaje dado que no soy tan habil a la hora de programar,
  de lo poco que supe lo hize y a la vez pedi ayuda a ChatGPT.

3. ¿Estoy más cerca de alcanzar el objetivo de la sesión? ¿Qué falta por hacer?

  R/= Estoy captando un poco mejor las cosas, per aun asi debo de continuar con la investigación.

4. ¿Qué he aprendido o reforzado en esta micro-sesión?

  R/=  La implementación y funcionamiento de la herencia en el lenguaje C.

**Cierre de sesión:**

5. ¿He alcanzado los objetivos planteados al inicio? Si no, ¿por qué y qué puedo mejorar?

  R/= Sí, todo y gracias a los ejercicios que estoy haciendo en la fase de investigación de la Unidad 3.

6. ¿Cuáles fueron los desafíos más significativos de hoy y cómo los superé?

  R/= Sin duda fue pasar el codigo base en lenguaje C a C#, intente por mi cuenta pero al final
  requeria ayuda de LA Inteligencia Artificial.

7. Basado en el trabajo de hoy, ¿qué insights importantes he ganado?

  R/= Solucionar el tema de la herencia en varios lenguajes y entender su funcionamiento.

8. ¿Cuáles son los pasos siguientes para continuar avanzando en el proyecto?

  R/= Hacer un diagrama del ejercicio anterior y avanzar en la investigacion de polimorfismo.


## Semana 11

### Sesión 1

1. ¿Cuál será el propósito de la sesión de hoy?

> Terminar los ejercicios relacionados al encapsulamiento (se me olvidaron) mas en concreto, el ejercicio 7. Luego hacer
  el diagrama de la herencia, para poder avanzar hacia polimorfismo.

  Ejemplo de encapsulamiento en lenguaje C:

  ```c
using System;

// Clase Shape
public class Shape
{
    private int x;
    private int y;

    // Constructor
    public Shape(int x, int y)
    {
        this.x = x;
        this.y = y;
    }

    // Método para mover la figura
    public void MoveBy(int dx, int dy)
    {
        x += dx;
        y += dy;
    }

    // Getter para la coordenada X
    public int GetX()
    {
        return x;
    }

    // Getter para la coordenada Y
    public int GetY()
    {
        return y;
    }
}

class Program
{
    static void Main(string[] args)
    {
        // Crear instancias de Shape
        Shape s1 = new Shape(0, 1);
        Shape s2 = new Shape(-1, 2);

        // Imprimir coordenadas iniciales
        Console.WriteLine($"Shape s1(x={s1.GetX()},y={s1.GetY()})");
        Console.WriteLine($"Shape s2(x={s2.GetX()},y={s2.GetY()})");

        // Mover las figuras
        s1.MoveBy(2, -4);
        s2.MoveBy(1, -2);

        // Imprimir coordenadas después de mover
        Console.WriteLine($"Shape s1(x={s1.GetX()},y={s1.GetY()})");
        Console.WriteLine($"Shape s2(x={s2.GetX()},y={s2.GetY()})");
    }
}

  ```

  ![image](https://github.com/jfUPB/bitacorassc2024-10-Lolman6542/assets/127360762/5dcf222d-fb8a-4a3e-b274-e7bbc2326252)

  Ahora presentera en el siguiente pantallazo el diagrama de clase de una herencia (basado en C#):
  
  ![image](https://github.com/jfUPB/bitacorassc2024-10-Lolman6542/assets/127360762/23197084-9e83-4578-a5f3-eb23d9ed6247)

 
2. ¿Cuáles fueron los desafíos más significativos de la sesión y cómo los superé?

> No hubo niguna dificultad tanto el digrama como el codigo en C# (ejercicio 7), ya que en el diagrama logre entender que Shape es la clase base que tiene dos miembros
  de datos, X e Y, representado las coordenadas de la forma en un plano bidimensional, Rectangle es una clase derivada de Shape.
  Contiene todos los miembros de Shape (x e y) como parte de su propia definición (super), ademas de tener dos miembros adicionales 
  para representar las dimensiones del rectángulo. La relación entre Rectangle y Shape es de herencia, donde Rectangle
  hereda todas las características de Shape y ademas tiene sus propias características adicionales.

3. Basado en el trabajo de la sesión, ¿Qué aprendí o qué conclusión saco o cuál es la síntesis?

>  Reforce por completo todo el tema de la herencia para poder avanzar a la siguiente etapa de la investigación.
   Como tal Rectangle hereda todas la caracteristicas de Shape y tiene caracteristicas adicionales.

4. ¿Cuáles son los pasos siguientes para continuar avanzando en el proyecto?

> Debo de terminar y/o empezar la fase de Polimorfismo de lo ejercicios para tener todo claro, acerca de la Unidad 3.

### Sesión 2

1. ¿Cuál será el propósito de la sesión de hoy?

> Indagar e investigar sobre el concepto de Polimorfismo

Se refiere a la capacidad de objetos de diferentes clases de responder al mismo mensaje (llamada a un método) 
de diferentes maneras. Esto permite que objetos de distintas clases puedan compartir un mismo nombre de método, 
pero cada clase puede implementar ese método de forma específica según sus propias necesidades y comportamientos,
todo mientras se hace en tiempo de ejeccución del programa.

Polimorfismo de tiempo de compilación (estático): También conocido como sobrecarga de método o sobrecarga de operador.
En este tipo de polimorfismo, se elige qué método llamar durante la fase de compilación basándose en el tipo estático
de la variable o el objeto. Esto significa que el compilador decide qué versión del método usar según la información 
disponible en tiempo de compilación.

Polimorfismo de tiempo de ejecución (dinámico): También conocido como sobrescritura de método. 
En este tipo de polimorfismo, el método a llamar se decide en tiempo de ejecución basándose en el tipo dinámico 
del objeto (el tipo real del objeto en tiempo de ejecución). Esto permite que un objeto se comporte 
de diferentes maneras según su tipo concreto en tiempo de ejecución.

![image](https://github.com/jfUPB/bitacorassc2024-10-Lolman6542/assets/127360762/37a2965f-8dc9-4b1e-81fa-52916dcdf280)

Demuestra cómo implementar polimorfismo en C utilizando punteros a funciones y una tabla de punteros a funciones 
para simular métodos virtuales y comportamientos polimórficos en un entorno orientado a objetos.
 
2. ¿Cuáles fueron los desafíos más significativos de la sesión y cómo los superé?

> Hasta el momento tenia algo confuso el tema debido a su similitud "muy vaga" con herencia, pero
gracias al una re-leectura de herencia y de este concepto ya me quedo claro que son distintas.

3. Basado en el trabajo de la sesión, ¿Qué aprendí o qué conclusión saco o cuál es la síntesis?

> Me quedo claro que el Polimorfismo tiene la capacidad de responder en tiempo real, a muchas ventas o
interfaces de manera distintas cada una.

4. ¿Cuáles son los pasos siguientes para continuar avanzando en el proyecto?

> Debo de continuar con los otros Ejercicios de la fase de Investigación, debo de comparar y analizar los codigos.

### Sesión 3

1. ¿Cuál será el propósito de la sesión de hoy?

> Escribe aquí
 
2. ¿Cuáles fueron los desafíos más significativos de la sesión y cómo los superé?

> Escribe aquí

3. Basado en el trabajo de la sesión, ¿Qué aprendí o qué conclusión saco o cuál es la síntesis?

> Escribe aquí

4. ¿Cuáles son los pasos siguientes para continuar avanzando en el proyecto?

> Escribe aquí


## Semana 12

### Sesión 1

1. ¿Cuál será el propósito de la sesión de hoy?

> Escribe aquí
 
2. ¿Cuáles fueron los desafíos más significativos de la sesión y cómo los superé?

> Escribe aquí

3. Basado en el trabajo de la sesión, ¿Qué aprendí o qué conclusión saco o cuál es la síntesis?

> Escribe aquí

4. ¿Cuáles son los pasos siguientes para continuar avanzando en el proyecto?

> Escribe aquí

### Sesión 2

1. ¿Cuál será el propósito de la sesión de hoy?

> Escribe aquí
 
2. ¿Cuáles fueron los desafíos más significativos de la sesión y cómo los superé?

> Escribe aquí

3. Basado en el trabajo de la sesión, ¿Qué aprendí o qué conclusión saco o cuál es la síntesis?

> Escribe aquí

4. ¿Cuáles son los pasos siguientes para continuar avanzando en el proyecto?

> Escribe aquí

### Sesión 3

1. ¿Cuál será el propósito de la sesión de hoy?

> Escribe aquí
 
2. ¿Cuáles fueron los desafíos más significativos de la sesión y cómo los superé?

> Escribe aquí

3. Basado en el trabajo de la sesión, ¿Qué aprendí o qué conclusión saco o cuál es la síntesis?

> Escribe aquí

4. ¿Cuáles son los pasos siguientes para continuar avanzando en el proyecto?

> Escribe aquí

## Semana 13

### Sesión 1

1. ¿Cuál será el propósito de la sesión de hoy?

> Escribe aquí
 
2. ¿Cuáles fueron los desafíos más significativos de la sesión y cómo los superé?

> Escribe aquí

3. Basado en el trabajo de la sesión, ¿Qué aprendí o qué conclusión saco o cuál es la síntesis?

> Escribe aquí

4. ¿Cuáles son los pasos siguientes para continuar avanzando en el proyecto?

> Escribe aquí

### Sesión 2

1. ¿Cuál será el propósito de la sesión de hoy?

> Escribe aquí
 
2. ¿Cuáles fueron los desafíos más significativos de la sesión y cómo los superé?

> Escribe aquí

3. Basado en el trabajo de la sesión, ¿Qué aprendí o qué conclusión saco o cuál es la síntesis?

> Escribe aquí

4. ¿Cuáles son los pasos siguientes para continuar avanzando en el proyecto?

> Escribe aquí

### Sesión 3

1. ¿Cuál será el propósito de la sesión de hoy?

> Escribe aquí
 
2. ¿Cuáles fueron los desafíos más significativos de la sesión y cómo los superé?

> Escribe aquí

3. Basado en el trabajo de la sesión, ¿Qué aprendí o qué conclusión saco o cuál es la síntesis?

> Escribe aquí

4. ¿Cuáles son los pasos siguientes para continuar avanzando en el proyecto?

> Escribe aquí
