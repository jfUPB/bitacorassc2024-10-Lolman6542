# Bitácora de aprendizaje

## ¿Cómo voy?

- [Sí] Terminé la fase de investigación. 
- [ ] Terminé la fase de aplicación.
- [ ] Terminé la fase de compartir.

## Compartir

### ¿Manejé bajo control de versión el código de mi aplicación?
### Muestro y explico mi implementación del encapsulamiento.
### Muestro y explico mi implementación de la herencia.
### Muestro y explico mi implementación del polimorfismo.
### Muestra cómo probaste la funcionalidad de cada característica de la aplicación,
### Muestra cómo probaste la integración de cada característica con las anteriores.

## Consejos para el uso efectivo de la bitácora

* Preparación al inicio de la micro-sesión 1: establece un objetivo claro de la sesión para maximizar el tiempo de trabajo efectivo.
* Concisión: sé breve pero significativo en tus respuestas para ajustarte al tiempo de reflexión de 4 minutos.
* Pausas activas: usa las pausas de 1 minutos para realmente desconectar, estirar y descansar los ojos; esto ayuda a mantener la energía y la concentración.
* Reflexión profunda al final de la mimcro-sesión 4: usa parte del tiempo para una reflexión más profunda y para planificar, asegurándote de cerrar la sesión
  con una nota productiva y prepararte para lo que sigue.

## Semana 10

### Sesión 1

#### Micro-sesión 1 (25 minutos)

**Planeación:**

1. ¿Qué voy a trabajar hoy?

   R/= Lo que se hara hoy es aprender o almmenos recordar conceptos de de Programacion orientada a objetos (POO)
   atravess del lenguage C que curiosamente no lo soporta, pero puede implementarse. Mas que todo revisar estos
   temas para largo, durante su desarrollo en la unidad. y en concreto el Refactoring.

2. ¿Cuál es mi objetivo principal para esta sesión?

   R/= Acordarme de los temas de POO y entender que es el Refactoring.

**Trabajo en concentración**

**Meta-aprendizaje:**

3. ¿Qué he logrado en esta micro-sesión de trabajo?

   R/= Un resumen de lo que trata que es POO. 
    La Programación Orientada a Objetos (POO) es un paradigma de programación que se basa en el concepto de "objetos".
    Estos objetos representan entidades del mundo real y tienen características (atributos) y comportamientos (métodos) asociados.
    La POO se centra en organizar el código de manera que las operaciones se realicen sobre objetos individuales, 
    lo que facilita la modularidad, la reutilización y la mantenibilidad del código., un resumen de lo que trata que es POO.

4. ¿Con qué dificultades me encontré y cómo las abordé?

   R/= Hasta el momento ninguno dado que ahora mismo estoy es revisando los conceptos
   y fueron abordados con ayuda del ChatGPT.

5. ¿Estoy más cerca de alcanzar el objetivo de la sesión? ¿Qué falta por hacer?

    R/= Si voy bien, debo de ver los conceptos claves de POO.

6. ¿Qué he aprendido o reforzado en esta micro-sesión? 
    
   R/= Poo se encarga de organizar los codigos de manera que las operaciones 
   se realicen sobre objetos individuales, facilitando la modularidad, 
   reutilizacion y mantebilidad de codigo, optimizandolo al maximo.

#### Micro-sesión 2 (25 minutos)

**Trabajo en concentración**

**Meta-aprendizaje:**

1. ¿Qué he logrado en esta micro-sesión de trabajo?

  R/= Encontrar de que es lo que trata los conceptos de Clases y Obejetos junto Encapsulamiento.

Clases y Objetos: 
Una clase es una plantilla o modelo para crear objetos. Define los atributos 
y métodos que tendrán los objetos de esa clase. 
Por ejemplo, una clase "Coche" puede tener atributos como color, marca, modelo, y métodos como acelerar, frenar, etc.
Un objeto es una instancia de una clase específica, es decir, una representación concreta de esa clase.

Encapsulamiento: 
Es el principio que consiste en ocultar los detalles internos de un objeto y exponer solo los métodos necesarios para interactuar con él.
Esto se logra mediante el uso de modificadores de acceso como public, private y protected 
en la definición de atributos y métodos de una clase.


2. ¿Con qué dificultades me encontré y cómo las abordé?

  R/= Hasta el momento ninguno dado que ahora mismo estoy es revisando los conceptos
   y fueron abordados con ayuda del ChatGPT.
    
3. ¿Estoy más cerca de alcanzar el objetivo de la sesión? ¿Qué falta por hacer?

  R/= Me encuentro mas cerca solo debo de seguir con los otros que falta por
  encontrar y entender.

4. ¿Qué he aprendido o reforzado en esta micro-sesión? 

  R/= En general, Los objetos son una represaticon de una clase y estas Clases son las 
  caracteristicas y atributos que poseen. Mientras que el encapsulamiento trata de ocultar
  detalles de los objetos mediante comandos que pueden usarse en las clases.

#### Micro-sesión 3 (25 minutos)

**Trabajo en concentración**

Herencia:
Permite crear una nueva clase (subclase o clase derivada) basada en una clase existente (superclase o clase base).
La subclase hereda los atributos y métodos de la superclase, lo que fomenta la reutilización de código y la jerarquía de clases. 
Por ejemplo, una subclase "SUV" podría heredar de la clase "Coche".

Polimorfismo:
Es la capacidad de un objeto para comportarse de diferentes formas según el contexto. Puede manifestarse de varias maneras,
como el sobrecargado de métodos (mismos nombres de métodos pero con diferentes parámetros) y la sobreescritura de métodos 
(métodos con el mismo nombre y firma en la clase base y sus subclases, pero con implementaciones diferentes).

**Meta-aprendizaje:**

1. ¿Qué he logrado en esta micro-sesión de trabajo?  

  R/= Sí ya encontre los conceptos que faltaban, de lo que es Herencia y Polimorfismo en resumen.

Herencia:
Permite crear una nueva clase (subclase o clase derivada) basada en una clase existente (superclase o clase base).
La subclase hereda los atributos y métodos de la superclase, lo que fomenta la reutilización de código y la jerarquía de clases. 
Por ejemplo, una subclase "SUV" podría heredar de la clase "Coche".

Polimorfismo:
Es la capacidad de un objeto para comportarse de diferentes formas según el contexto. Puede manifestarse de varias maneras,
como el sobrecargado de métodos (mismos nombres de métodos pero con diferentes parámetros) y la sobreescritura de métodos 
(métodos con el mismo nombre y firma en la clase base y sus subclases, pero con implementaciones diferentes).
  

2. ¿Con qué dificultades me encontré y cómo las abordé?

  R/= Hasta el momento ninguno dado que ahora mismo estoy es revisando los conceptos
    y fueron abordados con ayuda del ChatGPT.
   
4. ¿Estoy más cerca de alcanzar el objetivo de la sesión? ¿Qué falta por hacer?

  R/= En el momento si para cerrar esta sesión, solo faltaria el Refactory como tal.

5. ¿Qué he aprendido o reforzado en esta micro-sesión? 

  R/= Como tal herencia se puede era atributos de una clase, pasarcelas a otra que seria Superclase
  de los que cuales tendria los atributos de dicha clase que hereda y sus propios atributos por ser una nueva.
  Mientras que el polimorfismo al enviar el mismo mensaje desde distintos objetos, cada uno de esos objetos
  pueda responder a ese mensaje  de forma distinta. 

#### Micro-sesión 4. (25 minutos)

**Trabajo en concentración**

**Meta-aprendizaje:**

1. ¿Qué he logrado en esta micro-sesión de trabajo?

  R/= Un resumen de lo que trata el refactoring.
  El refactoring (o refactorización) es una técnica utilizada en programación para mejorar la estructura interna del código
sin cambiar su comportamiento externo. Básicamente, consiste en reorganizar el código para que sea más fácil 
de entender, mantener y modificar en el futuro, sin afectar su funcionalidad.

Algunas de las acciones comunes que se realizan durante el refactoring incluyen la eliminación de código duplicado,
la simplificación de bloques de código complejos, la mejora de nombres de variables y funciones para que sean más descriptivos,
y la reorganización de la estructura del código para que sea más coherente y legible.

2. ¿Con qué dificultades me encontré y cómo las abordé?
   
   R/= Hatas el momento, no me he encontrado ningun problema y lo resolvi con ayuda de chatGPT.
   
3. ¿Estoy más cerca de alcanzar el objetivo de la sesión? ¿Qué falta por hacer?

   R/= Si ya termine de revisar como tal el concepto de POO, por ahora no hay nada que hacer.

4. ¿Qué he aprendido o reforzado en esta micro-sesión?

   R/= Reduce la complejidad, facilita la detección y corrección de errores, y hace que el código sea más fácil
   de mantener y ampliar a medida que evoluciona el proyecto (Perdon si avanze antes).

**Cierre de sesión:**

5. ¿He alcanzado los objetivos planteados al inicio? Si no, ¿por qué y qué puedo mejorar?

R/= Si ya me acorde un poco mas de lo que iba POO y su refactoring, tengo que mejor la distribución del tiempo
y sintetizar mis respuestas.
  
6. ¿Cuáles fueron los desafíos más significativos de hoy y cómo los superé?

R/= Hasta el momento no a habido ningun problema, dado que lo que me dedique en esta sesion era un repaso 
de los conceptos de POO y el refactoring, tal vez lo mas complicado fue el tema refactoring, logre resolver mi dudas del temas
con investigaciones en internet y herramientas como ChatGPT.

7. Basado en el trabajo de hoy, ¿qué insights importantes he ganado?

R/= De que trata el tema de POO y sus conceptos. Por ahora ha sido simple, pero debo de seguir con su fase de experimetación.

8. ¿Cuáles son los pasos siguientes para continuar avanzando en el proyecto?

R/= Ahora mismo debo de seguir solucionando los otros Retos que hay en la fase de investigación, 
debo de poner aprueba o ejecutar los programas de Encapsulamiento con lenguaje C, en el visual.

### Sesión 2

#### Micro-sesión 1 (25 minutos)

**Planeación:**

1. ¿Qué voy a trabajar hoy?

R/= Continuare con los ejercicios de la fase de investigación, mas que todo empezar a ejecutar programas/codigos.

2. ¿Cuál es mi objetivo principal para esta sesión?

R/= Desatrasarme de las bitacoras de esta unidad, y mas que todo seguir continuando con la fase de investigación.
Respondi las siguientes preguntas que planteaba la bitacora:


**Trabajo en concentración**

**Meta-aprendizaje:**

3. ¿Qué he logrado en esta micro-sesión de trabajo?

R/= Me dedique hacer el ejercicio 1 dado que me lo habia saltado en la anterior sesión debido a que me dedique a buscar los conceptos.
- ¿En qué parte del programa se crean objetos?
  Estos se crean fuera de la función principal (main) utilizando el constructor "Shape_ctor". Si se crea un objeto Shape, llamariamos a 
  "Shape_ctor" con un puntero a una variable tipo Shape, pasando las coordenadas X e Y como argumentos.
- ¿En que parte de la memoria estan creados los objetos?
  Se almacenan en un segmento de memoria llamado "Heap", usando un operador malloc dentro del constructor "Shape_ctor", asignado
  de manera dinamica memoria en el heap durante el tiempo de ejecucion del programa.
- ¿Que es un Objeto?
  Es una instacia de una estructura o clase en POO , del cual cada objeto tiene sus propias variables y pueden tener sus 
  propios metodos asociados para manipular esos datos, tambien permiten mdelar entidades del mundo real dentro de un programa de computador y facilita
  la modularidad y reutilizacion de codigo.

![image](https://github.com/jfUPB/bitacorassc2024-10-Lolman6542/assets/127360762/188d84ff-ec28-4ef1-a919-312705b8ac93)


4. ¿Con qué dificultades me encontré y cómo las abordé?

  R/= No me he encontrado ninguna dificultad, aunque me toco usar una plantilla vieja de Pong para que funcionace el codigo.

5. ¿Estoy más cerca de alcanzar el objetivo de la sesión? ¿Qué falta por hacer?

  R/= No, debo de seguir contuniando con la fase de investigacion para seguir reportando en la bitacaro.

6. ¿Qué he aprendido o reforzado en esta micro-sesión? 

  R/= Por ahora esto otra vez reforzando el concepto de encapsulamiento y su implementacion en el programa,
  dado que la sesion pasada me puse a investifar los conceptos primero.

#### Micro-sesión 2 (25 minutos)

**Trabajo en concentración**

**Meta-aprendizaje:**

1. ¿Qué he logrado en esta micro-sesión de trabajo?

  R/= Para el ejercicio 3 hice el ejemplo el cual encapsulamos las propiedades de un rectangulo y un circulo dentro de
  las dentro de las estructuras Rectangle y Circle, respectivamente. Ademas implemente un metodo intersect para verificar   
  si los dos objetos se intersectan entre sí. En el bucle principal del programa dibujamos el rectangulo y el círculo  
  en la ventana de SDL y cambimos el color de la línea que los conecta dependiendo de si se intersectan o no.

2. ¿Con qué dificultades me encontré y cómo las abordé?

R/= Lo mas dificil fue hacer el ejercicio 3 ya que tuve varios errores en el codigo y no me compilaba correctamente,
del resto pude seguir y no se presento otro problema.
  
3. ¿Estoy más cerca de alcanzar el objetivo de la sesión? ¿Qué falta por hacer?

  R/= Aun faltan otros ejercicios de la fase de investiganción por responder...

4. ¿Qué he aprendido o reforzado en esta micro-sesión? 

  R/= Mas que todo en como implementar correctamente el encapsulamiento y fue hecho tomando como fuente el ejercicio 1.

#### Micro-sesión 3 (25 minutos)

**Trabajo en concentración**

**Meta-aprendizaje:**

1. ¿Qué he logrado en esta micro-sesión de trabajo?

  R/= Empece a responder preguntas acerca del ejercio 4 y 5 de lo que es un PLAN o MODELO. Basicamente el profesor 
  nos invita a que antes de que empecemos a programar, hay que pensar todas las cosas queremos diseñar e implementar,
  si a mucho tenerlo en papel. Tambien esta la pregunta del Constructor de una clase y su función, que en Lenguaje C
  utilizando las bibliotecas SDL un constructor de clase es similar, aunque el lenguaje y las bibliotecas puedan imponer
  algunas diferencias en su implementación, dado que no hay un concepto nativo de clases o constructores como lo hay 
  en otros como C++ O Java. Pero puede ser emulado un constructor en C definiendo una función que inicializa una estructura   
  específica con valores iniciales.

2. ¿Con qué dificultades me encontré y cómo las abordé?

  R/= Hasta el momento todo bien, pero talvez sea algo complicado al programarlo.

3. ¿Estoy más cerca de alcanzar el objetivo de la sesión? ¿Qué falta por hacer?

  R/= Aun falta ejercios por en la fase de investigacion, debo de seguir.

4. ¿Qué he aprendido o reforzado en esta micro-sesión? 

  R/= Que es mejor plantearse de lo que se puede y no se puede hacer con un lenguaje de programación,
  tanto conocer nuestros limites como del mismo lenguaje, para asi poder un buen diseño del mismo.


#### Micro-sesión 4. (25 minutos)

**Trabajo en concentración**

**Meta-aprendizaje:**

1. ¿Qué he logrado en esta micro-sesión de trabajo?

  R/= Estando en el ejercicio 6 ¿Cual es el estado y el comportamiento? El estado de un objeto Shape  
  se define por las propiedades X e Y, que representan las coordenas del plano bidimensional.
  Estas propiedades determinan la posición del Objeto en la ventana grafica y el Comportamiento  
  de un un objeto Shape se define por las funciones proporcionadas:  

  - Shape_ctor(Shape * const me, int16_t x, int16_t y): Inicia un objeto Shape con valores especificos para las coordenadas X e Y.
  - Shape_dtor(Shape * const me): Libera la memoria u realiza otras tareas de limpieza cuando un objeto Shape ya no es necesario.
  - Shape_moveby(Shape * const me, int16_t dx, int16_t dy): Permite mover el objeto Shape en la ventana gráfica agregando los  
    desplazamientos dx y dy a sus cooredenadas X e Y, respectivamente.
  - int16_t Shape_getX(Shape const * const me): Esta función devuelve la coordenada x actual del objeto Shape.
  - int16_t Shape_getY(Shape const * const me): Esta función devuelve la coordenada y actual del objeto Shape.


2. ¿Con qué dificultades me encontré y cómo las abordé?

  R/= Creo que debere ponerme en practica para lograr entender bien el concepto, antes de seguir estando perdido
  para su implementacion en lenguage C.

3. ¿Estoy más cerca de alcanzar el objetivo de la sesión? ¿Qué falta por hacer?

  R/= Estoy reforzando de a poco el tema de encapsulamiento, pero debo de seguir investigando para seguir resolviendo
  otros problemas o desafios.

4. ¿Qué he aprendido o reforzado en esta micro-sesión?

  R/= Que la clase llamada Shape, incluyen muchas funciones de las cuales puede crear, destruir, 
  mover y obtener las coordenadas de objetos Shape en un plano bidimensional.

**Cierre de sesión:**

5. ¿He alcanzado los objetivos planteados al inicio? Si no, ¿por qué y qué puedo mejorar?

  R/= se podria decir que sí, reforce una vez mas tema de encapsulamiento. Debo de contuniar con la fase de
  investigación para continuar reforzando y aprendiendo.

6. ¿Cuáles fueron los desafíos más significativos de hoy y cómo los superé?

  R/= Implementar POO en un lenguaje que no lo soportaba nativamente que en este caso es el C,
  pero con ayuda del tema Encapsulamiento, y sus ejercicios e investigación estoy alcanzandolo.

7. Basado en el trabajo de hoy, ¿qué insights importantes he ganado?

  R/= Hasta este momento el como implementar y entender el concepto de encapsulamiento.

8. ¿Cuáles son los pasos siguientes para continuar avanzando en el proyecto?

  R/= Ahora me tocara empezar a entender e implementar la función de la herencia y polimorfismo en lenguaje C para la otra sesión. 

### Sesión 3

#### Micro-sesión 1 (25 minutos)

**Planeación:**

1. ¿Qué voy a trabajar hoy?

  R/= Seguir trabajando en la Bitacora porque estoy muy atrasado.

2. ¿Cuál es mi objetivo principal para esta sesión?

  R/= Estare trabajando los siguientes ejercicios de la fase de investigación, que son herencia para poder implementarlos.

**Trabajo en concentración**

**Meta-aprendizaje:**

3. ¿Qué he logrado en esta micro-sesión de trabajo?

  R/= Salte hacia el ejercicio 9, cual tienes varias preguntas por responder. ¿Como se veria en memoria un
  objeto de la clase Shape? Ocuparía un bloque de memoria contiguo que contiene dos variables de tipo int16_t 
  para las coordenadas X e Y. Estas variables se almacenarían secuencialmente en la memoria, una despúes de la otra,
  dado que no hay ningun otro dato en la clase Shape. Por lo tanto, un objeto de la clase Shape simplemente contendría
  dos valores enteros de 16 bits consecutivos, representado la coordenadas X e Y, respectivamente. En ciertos casos
  el relleno de la estructura debido a la alineación de memoria, pueden afectar como se ve exactamente en la memoria.

  ¿Como se vería en memoria un objeto de la clase Rectangle? Se veria como un bloque contiguo que contiene tres
  variables: dos variables de tipo int16_t para las coordenadas X e Yheredadas de la clase Shape, y una variable de tipo 
  uint16_t para el ancho y otra para la altura del rectángulo. Las variables se almacenarían  secuencialmete en la 
  memoria en el orden en que estan definidas en la estructura Rectangle, siendo primero las coordenadas X e Y
  seguidas del ancho y la altura. Tambien el compilador se encargaria de rellenar para aegurar que las variables estén 
  alineadas correctamente en la memoria.

 
4. ¿Con qué dificultades me encontré y cómo las abordé?

  R/= Ninguna hasta el momento, debo de continuar con el desarrollo de los ejercicios para ver si me topo con una.

5. ¿Estoy más cerca de alcanzar el objetivo de la sesión? ¿Qué falta por hacer?

  R/= Falta mas información acerca de la herencia, para entenderlo. Hay que seguir haciendo los ejercicios.

6. ¿Qué he aprendido o reforzado en esta micro-sesión?

  R/= Ya se como luciria en memoria un objeto de la clase Shape y la clase Rectangle, aun falta mas por hacer. 

#### Micro-sesión 2 (25 minutos)

**Trabajo en concentración**

**Meta-aprendizaje:**

1. ¿Qué he logrado en esta micro-sesión de trabajo?

  R/= Continue con las preguntas del ejercicio de la herencia. ¿Que relación ves entre los dos objetos en terminos de
  en cómo se ven en memoria? Ambs objetos tienen una relación de compooosición. Esto se debe a que la clase
  Rectangle contiene un objeto de la clase Shape como miembro (super), en otras palabras, la estructura de Rectangle
  contendría los datos  de un objeto Shape (es decir, coordenadas X e Y) junto con su propio conjunto de datos (ancho y altura),
  todo en un bloque contiguo. Dando una relación entre un rectángulo y una forma en términos de diseño de software.
  Tambien un Rectangle es un shape debido a que la clase Rectangle hereda todas las propiedades y comportamientos 
  de la clase Shape e incluso puede tener sus propios atributos y comportamientos específicos de un rectángulo.
  Aunque Rectangle contiene un objeto Shape como un miembro, lo que implica una relácion de composición. Llegando a
  decir que un Rectangle tiene un Shape, en vez de ser uno.

2. ¿Con qué dificultades me encontré y cómo las abordé?

  R/= Hasta el momento todo va bien, su implementacion seria lo mas preocupante.

3. ¿Estoy más cerca de alcanzar el objetivo de la sesión? ¿Qué falta por hacer?

  R/= Aun no, debo de ver el polimorfismo, lo que sifnifica que debo de seguir investgando.

4. ¿Qué he aprendido o reforzado en esta micro-sesión? 

  R/=  Tengo claro como las clase Rectangle ereda de la clase Shape en el codigo del ejrcicio de la herencia.

#### Micro-sesión 3 (25 minutos)

**Trabajo en concentración**

**Meta-aprendizaje:**

1. ¿Qué he logrado en esta micro-sesión de trabajo?

  R/= Respondi la ultima pregunta del ejercicio de la herencia ¿Qué está pasando en el siguiente código? (Shape *)r1.
  El código, está realizando una conversión de tipo, convirtiendo un puntero r1 de tipo Rectangle a un puntero de tipo
  shappe. Esto se conoce como "casting" y está indicando al compilador que interprete el puntero r1 como un puntero a un objeto de la clase Shape,
  aunque técnicamente r1 es un puntero a un objeto de la clase Rectangle. Esta conversion es posible debido a la relación de herencia entre Rectangle
  y Shape, donde Rectangle es una subclase de Shape.

2. ¿Con qué dificultades me encontré y cómo las abordé?

  R/= No habia caido en cuenta que esa funcion era un puntero, pero investigando logre responder la pregunta.

3. ¿Estoy más cerca de alcanzar el objetivo de la sesión? ¿Qué falta por hacer?

  R/= Incluso aunque haya avanzado, me falta aun el polimorfismo, entoces debo de avanzar en eso para llegar mi objetivo.

4. ¿Qué he aprendido o reforzado en esta micro-sesión? 

  R/= La herencia es la habilidad de definir una nueva clase basada en clases existentes para reusar y organizar codigo.

#### Micro-sesión 4. (25 minutos)

**Trabajo en concentración**

**Meta-aprendizaje:**

1. ¿Qué he logrado en esta micro-sesión de trabajo?

  R/= Construi el siguiente codigo:

  ``` c
  using System;

// Clase base Shape
public class Shape
{
    public int x;
    public int y;

    // Constructor de Shape
    public Shape(int x, int y)
    {
        this.x = x;
        this.y = y;
    }

    // Método para mover la forma
    public virtual void MoveBy(int dx, int dy)
    {
        x += dx;
        y += dy;
    }

    // Método para obtener la coordenada x
    public int GetX()
    {
        return x;
    }

    // Método para obtener la coordenada y
    public int GetY()
    {
        return y;
    }
}

// Clase derivada Rectangle
public class Rectangle : Shape
{
    public int width;
    public int height;

    // Constructor de Rectangle
    public Rectangle(int x, int y, int width, int height) : base(x, y)
    {
        this.width = width;
        this.height = height;
    }
}

  
  ``` 
  Ahora compararemos esta versión en C# con la implementación original en C:

  Sintaxis: Son diferentes, En C# se utiliza llaves {} para delimitar bloques de código, los puntos y comas ; 
  al final de las declaraciones son obligatorios.

  Constructores: En C# utilizan constructores para inicializar los objetos, lo cual es similar al enfoque en C con las funciones Shape_ctor 
  y Rectangle_ctor. Sin embargo, en C# los contructores se llaman automáticamen al crear un objeto utilizando la palabra clave new.

  Métodos: Los metodos en C# se definen dentro de las clases y pueden ser virtuales, lo que permite la sobrescritura en clases derivadas,
  similar a los métodos en C con as funciones Shape_moveBy, Shape_getX y Shape_getY.

  Herencia: En C#, la herenciase especifica utilizando la palabra clave :, similar a la forma en que se realiza en C con la estructura Rectangle
  que contiene un miembro de tipo Shape. La clase derivada Rectangle hereda los miembros públicos y protegidos de la clase Shape.
  

2. ¿Con qué dificultades me encontré y cómo las abordé?

  R/= Lo mas dificil fue pasar el codigo a otro lenguaje dado que no soy tan habil a la hora de programar,
  de lo poco que supe lo hize y a la vez pedi ayuda a ChatGPT.

3. ¿Estoy más cerca de alcanzar el objetivo de la sesión? ¿Qué falta por hacer?

  R/= Estoy captando un poco mejor las cosas, per aun asi debo de continuar con la investigación.

4. ¿Qué he aprendido o reforzado en esta micro-sesión?

  R/=  La implementación y funcionamiento de la herencia en el lenguaje C.

**Cierre de sesión:**

5. ¿He alcanzado los objetivos planteados al inicio? Si no, ¿por qué y qué puedo mejorar?

  R/= Sí, todo y gracias a los ejercicios que estoy haciendo en la fase de investigación de la Unidad 3.

6. ¿Cuáles fueron los desafíos más significativos de hoy y cómo los superé?

  R/= Sin duda fue pasar el codigo base en lenguaje C a C#, intente por mi cuenta pero al final
  requeria ayuda de LA Inteligencia Artificial.

7. Basado en el trabajo de hoy, ¿qué insights importantes he ganado?

  R/= Solucionar el tema de la herencia en varios lenguajes y entender su funcionamiento.

8. ¿Cuáles son los pasos siguientes para continuar avanzando en el proyecto?

  R/= Hacer un diagrama del ejercicio anterior y avanzar en la investigacion de polimorfismo.


## Semana 11

### Sesión 1

1. ¿Cuál será el propósito de la sesión de hoy?

> Terminar los ejercicios relacionados al encapsulamiento (se me olvidaron) mas en concreto, el ejercicio 7. Luego hacer
  el diagrama de la herencia, para poder avanzar hacia polimorfismo.

  Ejemplo de encapsulamiento en lenguaje C:

  ```c
using System;

// Clase Shape
public class Shape
{
    private int x;
    private int y;

    // Constructor
    public Shape(int x, int y)
    {
        this.x = x;
        this.y = y;
    }

    // Método para mover la figura
    public void MoveBy(int dx, int dy)
    {
        x += dx;
        y += dy;
    }

    // Getter para la coordenada X
    public int GetX()
    {
        return x;
    }

    // Getter para la coordenada Y
    public int GetY()
    {
        return y;
    }
}

class Program
{
    static void Main(string[] args)
    {
        // Crear instancias de Shape
        Shape s1 = new Shape(0, 1);
        Shape s2 = new Shape(-1, 2);

        // Imprimir coordenadas iniciales
        Console.WriteLine($"Shape s1(x={s1.GetX()},y={s1.GetY()})");
        Console.WriteLine($"Shape s2(x={s2.GetX()},y={s2.GetY()})");

        // Mover las figuras
        s1.MoveBy(2, -4);
        s2.MoveBy(1, -2);

        // Imprimir coordenadas después de mover
        Console.WriteLine($"Shape s1(x={s1.GetX()},y={s1.GetY()})");
        Console.WriteLine($"Shape s2(x={s2.GetX()},y={s2.GetY()})");
    }
}

  ```

  ![image](https://github.com/jfUPB/bitacorassc2024-10-Lolman6542/assets/127360762/5dcf222d-fb8a-4a3e-b274-e7bbc2326252)

  Ahora presentera en el siguiente pantallazo el diagrama de clase de una herencia (basado en C#):
  
  ![image](https://github.com/jfUPB/bitacorassc2024-10-Lolman6542/assets/127360762/23197084-9e83-4578-a5f3-eb23d9ed6247)

 
2. ¿Cuáles fueron los desafíos más significativos de la sesión y cómo los superé?

> No hubo niguna dificultad tanto el digrama como el codigo en C# (ejercicio 7), ya que en el diagrama logre entender que Shape es la clase base que tiene dos miembros
  de datos, X e Y, representado las coordenadas de la forma en un plano bidimensional, Rectangle es una clase derivada de Shape.
  Contiene todos los miembros de Shape (x e y) como parte de su propia definición (super), ademas de tener dos miembros adicionales 
  para representar las dimensiones del rectángulo. La relación entre Rectangle y Shape es de herencia, donde Rectangle
  hereda todas las características de Shape y ademas tiene sus propias características adicionales.

3. Basado en el trabajo de la sesión, ¿Qué aprendí o qué conclusión saco o cuál es la síntesis?

>  Reforce por completo todo el tema de la herencia para poder avanzar a la siguiente etapa de la investigación.
   Como tal Rectangle hereda todas la caracteristicas de Shape y tiene caracteristicas adicionales.

4. ¿Cuáles son los pasos siguientes para continuar avanzando en el proyecto?

> Debo de terminar y/o empezar la fase de Polimorfismo de lo ejercicios para tener todo claro, acerca de la Unidad 3.

### Sesión 2

1. ¿Cuál será el propósito de la sesión de hoy?

> Indagar e investigar sobre el concepto de Polimorfismo.
Se refiere a la capacidad de objetos de diferentes clases de responder al mismo mensaje (llamada a un método) 
de diferentes maneras. Esto permite que objetos de distintas clases puedan compartir un mismo nombre de método, 
pero cada clase puede implementar ese método de forma específica según sus propias necesidades y comportamientos,
todo mientras se hace en tiempo de ejeccución del programa.

> Polimorfismo de tiempo de compilación, se elige qué método llamar durante la fase de compilación basándose en el tipo estático
de la variable o el objeto. Polimorfismo de tiempo de ejecución, el método a llamar se decide en tiempo de ejecución basándose en el tipo dinámico 
del objeto (el tipo real del objeto en tiempo de ejecución). Esto permite que un objeto se comporte 
de diferentes maneras según su tipo concreto en tiempo de ejecución.
![image](https://github.com/jfUPB/bitacorassc2024-10-Lolman6542/assets/127360762/37a2965f-8dc9-4b1e-81fa-52916dcdf280)

> Demuestra cómo implementar polimorfismo en C utilizando punteros a funciones y una tabla de punteros a funciones 
para simular métodos virtuales y comportamientos polimórficos en un entorno orientado a objetos.
 
2. ¿Cuáles fueron los desafíos más significativos de la sesión y cómo los superé?

> Hasta el momento tenia algo confuso el tema debido a su similitud "muy vaga" con herencia, pero
gracias al una re-leectura de herencia y de este concepto ya me quedo claro que son distintas.

3. Basado en el trabajo de la sesión, ¿Qué aprendí o qué conclusión saco o cuál es la síntesis?

> Me quedo claro que el Polimorfismo tiene la capacidad de responder en tiempo real, a muchas ventas o
interfaces de manera distintas cada una.

4. ¿Cuáles son los pasos siguientes para continuar avanzando en el proyecto?

> Debo de continuar con los otros Ejercicios de la fase de Investigación, debo de comparar y analizar los codigos.

### Sesión 3

1. ¿Cuál será el propósito de la sesión de hoy?

> Seguir trabajando la fase de investigación, en el cual me encargare de hacer el ejrecicio 13.
Aca dejo puesto el codigo que estube creando en C#:

```c
using System;

// Interfaz para operaciones de forma
public interface IShapeOperations
{
    uint Area();
    void Draw();
}

// Clase base Shape
public class Shape
{
    protected int x;
    protected int y;
    protected IShapeOperations operations;

    // Constructor de Shape
    public Shape(int x, int y, IShapeOperations operations)
    {
        this.x = x;
        this.y = y;
        this.operations = operations;
    }
}

// Clase Rectangle
public class Rectangle : Shape
{
    private uint width;
    private uint height;

    // Constructor de Rectangle
    public Rectangle(int x, int y, uint width, uint height, IShapeOperations operations) 
        : base(x, y, operations)
    {
        this.width = width;
        this.height = height;
    }
}

// Clase Circle
public class Circle : Shape
{
    private uint radius;

    // Constructor de Circle
    public Circle(int x, int y, uint radius, IShapeOperations operations) 
        : base(x, y, operations)
    {
        this.radius = radius;
    }
}
```
> Se utiliza una interfaz iShapeOperations para definir las operaciones comunes de una forma.
> La clase base Shape cpntiene propiedades X e Y para representar las coordenadas de una forma, asi como una
referencia a una interfaz IshapeOperations para las operaciones de forma.
> La clase Rectangle hereda de Shape y agrega propiedades adicionales width y height para representar
las dumensiones del rectángulo.
> La clase Circle también hereda de Shape y agrega la propiedad radius para representar el radio del círculo.

 
2. ¿Cuáles fueron los desafíos más significativos de la sesión y cómo los superé?

> Fue el traslado del codigo a lenguaje C#, recurrir a videos de youtube para ver ejemplos de estos.

3. Basado en el trabajo de la sesión, ¿Qué aprendí o qué conclusión saco o cuál es la síntesis?

> He reforzado la implementación del polimorfismo y he intertar usar el tema en pong.

4. ¿Cuáles son los pasos siguientes para continuar avanzando en el proyecto?

>  Ya me encuentro cada vez mas cerca de la linea de meta para finalizar la fase de investigación y ver que puedo hacer
del desafio.


## Semana 12

### Sesión 1

1. ¿Cuál será el propósito de la sesión de hoy?

> Realize el diagrama del arbol del ejercicio del polimorfismo.

![image](https://github.com/jfUPB/bitacorassc2024-10-Lolman6542/assets/127360762/4cde50a7-bb4e-4c36-9114-ab936802b64f)


> Tambien basado a un codigo que habia en el ejercicio 12, este código es una implementación básica de un sistema de 
clases en C# para representar formas geométricas. Cada forma (rectángulo, círculo) hereda de la clase base Shape, 
lo que permite compartir comportamientos comunes y acceder a métodos específicos de cada forma a través de la interfaz IShapeOperations.
 
2. ¿Cuáles fueron los desafíos más significativos de la sesión y cómo los superé?

> En estos momento no me encotre con niguna dificultad en el trancurso de la investigacion, aunque no estoy tan seguro
de su implemetacion.

3. Basado en el trabajo de la sesión, ¿Qué aprendí o qué conclusión saco o cuál es la síntesis?

> Se finalizo el refuerzo sobre el polimorfismo dejando claro su funcionamiento de este en 
ambos lenguajes.

4. ¿Cuáles son los pasos siguientes para continuar avanzando en el proyecto?

> Hacer los ultimos puntos de la fase de investigacion aca en la bitacora

### Sesión 2

1. ¿Cuál será el propósito de la sesión de hoy?

> Me encargue de hacer el ejercicio 15 mostrando un ejemplo de Interfaces
![image](https://github.com/jfUPB/bitacorassc2024-10-Lolman6542/assets/127360762/c19038a9-61ab-4a69-8a72-10888b7c1a3b)


```c
#include <stdio.h>
#include <stdint.h>  // Necesario para uint32_t
#include <stdlib.h>

// Definición de la interfaz para operaciones de forma
typedef struct IShapeOperations {
    uint32_t(*area)();
    void (*draw)();
} IShapeOperations;

// Definición de la clase base Shape
typedef struct Shape {
    int x;
    int y;
    IShapeOperations* operations;
} Shape;

// Constructor de Shape
void Shape_ctor(Shape* me, int x, int y, IShapeOperations* operations) {
    me->x = x;
    me->y = y;
    me->operations = operations;
}

// Clase Rectangle
typedef struct Rectangle {
    Shape base;
    uint32_t width;
    uint32_t height;
} Rectangle;

// Constructor de Rectangle
void Rectangle_ctor(Rectangle* me, int x, int y, uint32_t width, uint32_t height, IShapeOperations* operations) {
    Shape_ctor((Shape*)me, x, y, operations);
    me->width = width;
    me->height = height;
}

// Métodos de área y dibujo para Rectangle
uint32_t Rectangle_area(Rectangle* me) {
    return me->width * me->height;
}

void Rectangle_draw(Rectangle* me) {
    printf("Drawing Rectangle at (%d, %d) with width=%u and height=%u\n", me->base.x, me->base.y, me->width, me->height);
}

// Clase Circle
typedef struct Circle {
    Shape base;
    uint32_t radius;
} Circle;

// Constructor de Circle
void Circle_ctor(Circle* me, int x, int y, uint32_t radius, IShapeOperations* operations) {
    Shape_ctor((Shape*)me, x, y, operations);
    me->radius = radius;
}

// Métodos de área y dibujo para Circle
uint32_t Circle_area(Circle* me) {
    return 3 * me->radius * me->radius;
}

void Circle_draw(Circle* me) {
    printf("Drawing Circle at (%d, %d) with radius=%u\n", me->base.x, me->base.y, me->radius);
}

// Función para dibujar una forma
void drawShape(Shape* shape) {
    shape->operations->draw(shape);
}

int main() {
    // Definición de las operaciones para Rectangle
    IShapeOperations rectOperations = { (uint32_t(*)())Rectangle_area, (void (*)())Rectangle_draw };

    // Creación de un Rectangle
    Rectangle rect;
    Rectangle_ctor(&rect, 0, 0, 10, 5, &rectOperations);

    // Dibujar el Rectangle
    drawShape((Shape*)&rect);

    // Definición de las operaciones para Circle
    IShapeOperations circleOperations = { (uint32_t(*)())Circle_area, (void (*)())Circle_draw };

    // Creación de un Circle
    Circle circle;
    Circle_ctor(&circle, 3, 3, 7, &circleOperations);

    // Dibujar el Circle
    drawShape((Shape*)&circle);

    return 0;
}


```
> 
 
2. ¿Cuáles fueron los desafíos más significativos de la sesión y cómo los superé?

>  Como tal tube que simular el concepto de interfaces y clases en C utilizando punteros
 a funciones para lograr comportamientos polimórficos.

3. Basado en el trabajo de la sesión, ¿Qué aprendí o qué conclusión saco o cuál es la síntesis?

> En como implementar las interfaces con ayuda de los punteros.

4. ¿Cuáles son los pasos siguientes para continuar avanzando en el proyecto?

> Hacer El ultimo ejercicio de la fase de investigación, para asi concluirla.

### Sesión 3

1. ¿Cuál será el propósito de la sesión de hoy?

> Voy analizar el siguiente codigo:
```c
/*
* This code is based on C# code from this site:
* https://refactoring.guru/design-patterns/command/csharp/example
*/

#include <stdio.h>
#include <stdlib.h>

typedef struct ICommand ICommand;
typedef struct Receiver Receiver;
typedef struct SimpleCommand SimpleCommand;
typedef struct ComplexCommand ComplexCommand;

/*****************************************************
* Interface
******************************************************/
struct ICommand {
    void (*execute)(ICommand *);
};

void Execute(ICommand *me){
    me->execute(me);
}

/*****************************************************
* Class
******************************************************/
struct Receiver {
    void (*doSomething)(Receiver *, char *);
    void (*doSomethingElse)(Receiver *, char *);
};


void Receiver_ctor(Receiver *me, void (*doSomething)(Receiver *, char *), void (*doSomethingElse)(Receiver *, char *) ){
    me->doSomething = doSomething;
    me->doSomethingElse = doSomethingElse;
}

void Receiver_doSomething(Receiver *me, char *a) {
    printf("Receiver: Working on (%s).\n", a);
}

void Receiver_doSomethingElse(Receiver *me, char *b) {
    printf("Receiver: Also working on (%s).\n", b);
}

/*****************************************************
* Class
******************************************************/

struct SimpleCommand {
    ICommand base;
    char* payload;
};

void SimpleCommand_execute(ICommand *command) {
    SimpleCommand *me = (SimpleCommand *)command;
    printf("SimpleCommand: See, I can do simple things like printing (%s)\n", me->payload);
}

void SimpleCommand_ctor(SimpleCommand *me,char *payload) {
    me->base.execute = SimpleCommand_execute;
    me->payload = payload;
}

/*****************************************************
* Class
******************************************************/
struct ComplexCommand {
    ICommand base;
    Receiver *receiver;
    char *a;
    char *b;
};

void ComplexCommand_execute(ICommand *command) {
    ComplexCommand *me = (ComplexCommand*)command;
    printf("ComplexCommand: Complex stuff should be done by a receiver object.\n");
    me->receiver->doSomething(me->receiver, me->a);
    me->receiver->doSomethingElse(me->receiver, me->b);
}

void ComplexCommand_ctor(ComplexCommand *me, Receiver *receiver, char *a, char *b){
    me->base.execute = ComplexCommand_execute;
    me->receiver = receiver;
    me->a = a;
    me->b = b;
}

int main() {

    Receiver *receiver = malloc( sizeof(Receiver) );
    Receiver_ctor(receiver,Receiver_doSomething,Receiver_doSomethingElse);

    SimpleCommand  *simpleCommand =  malloc(sizeof(SimpleCommand));
    SimpleCommand_ctor(simpleCommand,"Say Hi!");

    ComplexCommand *complexCommand = (ComplexCommand*)malloc(sizeof(ComplexCommand));
    ComplexCommand_ctor(complexCommand, receiver, "Send email", "to John");

    ICommand* commands[2] = {(ICommand *) simpleCommand, (ICommand *)complexCommand};

    for (int i = 0; i < 2; i++) {
       Execute(commands[i]);
    }

    free(simpleCommand);
    free(complexCommand);
    free(receiver);

    return 0;
}
```

> Encapsula acciones como objetos, utiliza polimorfismo para ejecutar diferentes comandos a través de una interfaz común 
y organiza los datos en memoria de acuerdo con la estructura de las clases y sus relaciones.

> Zona de Código se encuentran las instrucciones y estructuras de datos estáticos. 
  Text (Texto) Contiene las instrucciones de la función main y otras funciones definidas en el código.
  BSS y Data No están representados explícitamente en el diagrama, pero podrían contener datos estáticos como variables globales o estáticas.
  Heap con los simplecommmands y complexcommands. Stack contiene los Main y commands.
  
> El polimorfismo permite que objetos de diferentes clases se puedan tratar de manera uniforme a través de una interfaz común.  
 
2. ¿Cuáles fueron los desafíos más significativos de la sesión y cómo los superé?

> En cómo se organiza la memoria en un programa, incluyendo el stack, heap y otras secciones. 
  Separando cada seccion para ver en donde pertenecian.

3. Basado en el trabajo de la sesión, ¿Qué aprendí o qué conclusión saco o cuál es la síntesis?

> Que debo de prestar mas atención en donde pueden haber cambios drasticos o 
  ver que es lo que me imprime la consola para que no haya errores de memoria.

4. ¿Cuáles son los pasos siguientes para continuar avanzando en el proyecto?

> Ahora mismo lo mejor seria hecharle un repaso otra vez al concepto. y ver que puedo planear...

## Semana 13

### Sesión 1

1. ¿Cuál será el propósito de la sesión de hoy?

> Ahora mismo lo mejor seria revisar los conceptos:
Encapsulamiento consiste en ocultar los detalles internos de un objeto y exponer solo las partes necesarias para interactuar con él.
Se logra mediante el uso de modificadores de acceso como public, private y protectedpara controlar el acceso a los miembros de una clase.
Proporciona beneficios como la protección de datos, la simplificación de la interfaz de uso de objetos y la facilitación del mantenimiento 
del código al poder cambiar internamente la implementación sin afectar a los usuarios externos.

> Herencia permite a una clase heredar los atributos y métodos de otra clase.
Permite la reutilización de código al evitar la duplicación de funcionalidades comunes entre clases.
La clase derivada puede agregar nuevos miembros o modificar el comportamiento de los miembros heredados
mediante la sobrescritura de métodos o la adición de nuevos métodos y atributos.

> Polimorfismo se refiere a la capacidad de un objeto de comportarse de múltiples formas. Permite tratar objetos de clases diferentes
 de manera uniforme a través de referencias a la clase base, lo que facilita la escritura de código genérico y flexible.

>Estos conceptos son fundamentales para el diseño de software orientado a objetos eficiente, modular y fácil de mantener.
 
2. ¿Cuáles fueron los desafíos más significativos de la sesión y cómo los superé?

> Hasta el momento no fue ninguno, todo lo que hice fue volver a buscar y repasar los tres conceptos mencionados.

3. Basado en el trabajo de la sesión, ¿Qué aprendí o qué conclusión saco o cuál es la síntesis?

> El encapsulamiento protege la implementación interna, la herencia permite la reutilización de código
y la especialización de clases, y el polimorfismo permite tratar objetos de manera más generalizada y flexible.

4. ¿Cuáles son los pasos siguientes para continuar avanzando en el proyecto?

> Ahora mismo lo mejor seria hacer una planeacion y/o seguir investigando cosas del tema.

### Sesión 2

1. ¿Cuál será el propósito de la sesión de hoy?

> Ahora mismo lo que voy hacer es un analizasis al codigo que tengo de pong para entender sus funciones.
```c
#include <stdio.h>
#include <SDL.h>
#include <SDL_ttf.h>

#define TRUE 1
#define FALSE 0
#define WINDOW_WIDTH 800
#define WINDOW_HEIGHT 600
#define FPS 60
#define FRAME_TARGET_TIME (1000/FPS)

// Global variables
int game_is_running = FALSE;
SDL_Window* window = NULL;
SDL_Renderer* renderer = NULL;
int last_frame_time = 0;
int score_player_bottom = 0; // Score for player at bottom
int score_player_top = 0;    // Score for player at top

// Game object struct
struct game_object {
    float x;
    float y;
    float width;
    float height;
    float vel_x;
    float vel_y;
} ball, paddle_bottom, paddle_top;

// Font and text rendering variables
TTF_Font* font = NULL;
SDL_Texture* score_text = NULL;
SDL_Color text_color = { 255, 255, 255, 255 }; // White text color

// Function to initialize the SDL window
int initialize_window(void) {
    if (SDL_Init(SDL_INIT_EVERYTHING) != 0) {
        fprintf(stderr, "Error initializing SDL.\n");
        return FALSE;
    }
    window = SDL_CreateWindow(
        NULL,
        SDL_WINDOWPOS_CENTERED,
        SDL_WINDOWPOS_CENTERED,
        WINDOW_WIDTH,
        WINDOW_HEIGHT,
        SDL_WINDOW_BORDERLESS
    );
    if (!window) {
        fprintf(stderr, "Error creating SDL Window.\n");
        return FALSE;
    }
    renderer = SDL_CreateRenderer(window, -1, 0);
    if (!renderer) {
        fprintf(stderr, "Error creating SDL Renderer.\n");
        return FALSE;
    }

    // Initialize SDL_ttf
    if (TTF_Init() == -1) {
        fprintf(stderr, "Error initializing SDL_ttf: %s\n", TTF_GetError());
        return FALSE;
    }

    // Load font
    font = TTF_OpenFont("Pixelmania.ttf", 16); // Change the font path if needed
    if (!font) {
        fprintf(stderr, "Error loading font: %s\n", TTF_GetError());
        return FALSE;
    }

    return TRUE;
}

// Function to process input events
void process_input(void) {
    SDL_Event event;
    SDL_PollEvent(&event);
    switch (event.type) {
    case SDL_QUIT:
        game_is_running = FALSE;
        break;
    case SDL_KEYDOWN:
        if (event.key.keysym.sym == SDLK_ESCAPE)
            game_is_running = FALSE;
        if (event.key.keysym.sym == SDLK_LEFT)
            paddle_bottom.vel_x = -400;
        if (event.key.keysym.sym == SDLK_RIGHT)
            paddle_bottom.vel_x = +400;
        if (event.key.keysym.sym == SDLK_a)
            paddle_top.vel_x = -400;
        if (event.key.keysym.sym == SDLK_d)
            paddle_top.vel_x = +400;
        break;
    case SDL_KEYUP:
        if (event.key.keysym.sym == SDLK_LEFT)
            paddle_bottom.vel_x = 0;
        if (event.key.keysym.sym == SDLK_RIGHT)
            paddle_bottom.vel_x = 0;
        if (event.key.keysym.sym == SDLK_a)
            paddle_top.vel_x = 0;
        if (event.key.keysym.sym == SDLK_d)
            paddle_top.vel_x = 0;
        break;
    }
}

// Function to set up the game
void setup(void) {
    // Initialize values for the ball object
    ball.width = 15;
    ball.height = 15;
    ball.x = 20;
    ball.y = 20;
    ball.vel_x = 300;
    ball.vel_y = 300;

    // Initialize values for the bottom paddle object
    paddle_bottom.width = 100;
    paddle_bottom.height = 20;
    paddle_bottom.x = (WINDOW_WIDTH / 2) - (paddle_bottom.width / 2);
    paddle_bottom.y = WINDOW_HEIGHT - 40;
    paddle_bottom.vel_x = 0;
    paddle_bottom.vel_y = 0;

    // Initialize values for the top paddle object
    paddle_top.width = 100;
    paddle_top.height = 20;
    paddle_top.x = (WINDOW_WIDTH / 2) - (paddle_top.width / 2);
    paddle_top.y = 20;
    paddle_top.vel_x = 0;
    paddle_top.vel_y = 0;
}

// Function to update game state
void update(void) {
    // Calculate time to wait until the target frame time
    int time_to_wait = FRAME_TARGET_TIME - (SDL_GetTicks() - last_frame_time);

    // Only delay if we are too fast to update this frame
    if (time_to_wait > 0 && time_to_wait <= FRAME_TARGET_TIME)
        SDL_Delay(time_to_wait);

    // Calculate delta time factor for updating objects
    float delta_time = (SDL_GetTicks() - last_frame_time) / 1000.0F;

    // Store milliseconds of the current frame
    last_frame_time = SDL_GetTicks();

    // Update ball and paddle positions
    ball.x += ball.vel_x * delta_time;
    ball.y += ball.vel_y * delta_time;
    paddle_bottom.x += paddle_bottom.vel_x * delta_time;
    paddle_bottom.y += paddle_bottom.vel_y * delta_time;
    paddle_top.x += paddle_top.vel_x * delta_time;
    paddle_top.y += paddle_top.vel_y * delta_time;

    // Check for ball collision with walls
    if (ball.x <= 0 || ball.x + ball.width >= WINDOW_WIDTH)
        ball.vel_x = -ball.vel_x;
    if (ball.y < 0)
        ball.vel_y = -ball.vel_y;

    // Check if ball passed top or bottom of the screen
    if (ball.y + ball.height > WINDOW_HEIGHT) {
        ball.x = WINDOW_WIDTH / 2;
        ball.y = WINDOW_HEIGHT / 2;
        ball.vel_y = -ball.vel_y;
        score_player_top++;
    }
    if (ball.y < 0) {
        ball.x = WINDOW_WIDTH / 2;
        ball.y = WINDOW_HEIGHT / 2;
        ball.vel_y = -ball.vel_y;
        score_player_bottom++;
    }

    // Check for ball collision with paddles
    if (ball.y + ball.height >= paddle_bottom.y && ball.x + ball.width >= paddle_bottom.x && ball.x <= paddle_bottom.x + paddle_bottom.width) {
        ball.vel_y = -ball.vel_y;
    }
    if (ball.y <= paddle_top.y + paddle_top.height && ball.x + ball.width >= paddle_top.x && ball.x <= paddle_top.x + paddle_top.width) {
        ball.vel_y = -ball.vel_y;
    }

    // Prevent paddles from moving outside window boundaries
    if (paddle_bottom.x <= 0)
        paddle_bottom.x = 0;
    if (paddle_bottom.x >= WINDOW_WIDTH - paddle_bottom.width)
        paddle_bottom.x = WINDOW_WIDTH - paddle_bottom.width;
    if (paddle_top.x <= 0)
        paddle_top.x = 0;
    if (paddle_top.x >= WINDOW_WIDTH - paddle_top.width)
        paddle_top.x = WINDOW_WIDTH - paddle_top.width;
}

// Function to render game objects
void render(void) {
    SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
    SDL_RenderClear(renderer);

    // Draw ball
    SDL_Rect ball_rect = { (int)ball.x, (int)ball.y, (int)ball.width, (int)ball.height };
    SDL_SetRenderDrawColor(renderer, 255, 255, 255, 255);
    SDL_RenderFillRect(renderer, &ball_rect);

    // Draw bottom paddle
    SDL_Rect paddle_bottom_rect = { (int)paddle_bottom.x, (int)paddle_bottom.y, (int)paddle_bottom.width, (int)paddle_bottom.height };
    SDL_RenderFillRect(renderer, &paddle_bottom_rect);

    // Draw top paddle
    SDL_Rect paddle_top_rect = { (int)paddle_top.x, (int)paddle_top.y, (int)paddle_top.width, (int)paddle_top.height };
    SDL_RenderFillRect(renderer, &paddle_top_rect);

    // Render score text for player at bottom
    char score_str_bottom[20];
    snprintf(score_str_bottom, sizeof(score_str_bottom), "Player Bottom: %d", score_player_bottom);
    SDL_Surface* text_surface_bottom = TTF_RenderText_Solid(font, score_str_bottom, text_color);
    if (text_surface_bottom) {
        SDL_Texture* text_texture_bottom = SDL_CreateTextureFromSurface(renderer, text_surface_bottom);
        SDL_FreeSurface(text_surface_bottom);
        if (text_texture_bottom) {
            SDL_Rect text_rect_bottom = { 10, WINDOW_HEIGHT - 30, 200, 30 };
            SDL_QueryTexture(text_texture_bottom, NULL, NULL, &text_rect_bottom.w, &text_rect_bottom.h);
            SDL_RenderCopy(renderer, text_texture_bottom, NULL, &text_rect_bottom);
            SDL_DestroyTexture(text_texture_bottom);
        }
    }

    // Render score text for player at top
    char score_str_top[20];
    snprintf(score_str_top, sizeof(score_str_top), "Player Top: %d", score_player_top);
    SDL_Surface* text_surface_top = TTF_RenderText_Solid(font, score_str_top, text_color);
    if (text_surface_top) {
        SDL_Texture* text_texture_top = SDL_CreateTextureFromSurface(renderer, text_surface_top);
        SDL_FreeSurface(text_surface_top);
        if (text_texture_top) {
            SDL_Rect text_rect_top = { 10, 10, 200, 30 };
            SDL_QueryTexture(text_texture_top, NULL, NULL, &text_rect_top.w, &text_rect_top.h);
            SDL_RenderCopy(renderer, text_texture_top, NULL, &text_rect_top);
            SDL_DestroyTexture(text_texture_top);
        }
    }

    SDL_RenderPresent(renderer);
}

// Function to destroy SDL window and renderer
void destroy_window(void) {
    SDL_DestroyRenderer(renderer);
    SDL_DestroyWindow(window);
    SDL_Quit();
}

// Main function
int main(int argc, char* argv[]) {
    game_is_running = initialize_window();

    setup();

    while (game_is_running) {
        process_input();
        update();
        render();
    }

    destroy_window();

    return 0;
}
````

> En resumen, el código establece un juego simple de Pong donde el jugador controla dos paletas para golpear una pelota y marcar puntos.
 Utiliza SDL para la representación gráfica y TTF para el texto, y sigue un ciclo típico de eventos, actualización y renderizado en cada frame del juego.

> El código utiliza la biblioteca SDL (Simple DirectMedia Layer) y SDL_ttf para crear una ventana gráfica y renderizar elementos en ella.
  Define constantes como WINDOW_WIDTH, WINDOW_HEIGHT y FPS para el tamaño de la ventana y la frecuencia de actualización.
  Inicializa variables globales como game_is_running para controlar el ciclo del juego, y define punteros a la ventana y al renderizador (window y renderer).

> La función process_input() maneja eventos de entrada del usuario, como teclas presionadas y liberadas, para controlar el movimiento de las paletas y salir del juego.
  Utiliza la biblioteca SDL para detectar eventos como teclas presionadas (SDL_KEYDOWN) y actualizar las velocidades de las paletas en consecuencia.

> La función main() inicializa el entorno gráfico, configura el juego, y entra en un bucle principal donde se procesan eventos,
  se actualiza el estado y se renderizan los objetos hasta que el usuario decide salir. Al salir del juego, se libera la memoria y se destruyen los recursos gráficos utilizados.

Partes del codigo para beneficiarce de una refactorizacion:

> Los bloques de código para manejar las teclas presionadas (SDL_KEYDOWN) y liberadas (SDL_KEYUP) están duplicados 
  para las teclas de movimiento de las paletas. Se puede refactorizar para eliminar la duplicación y mejorar la legibilidad y mantenibilidad del código.

> La función setup() inicializa valores para la pelota y las paletas, pero esta lógica podría separarse aún más para 
  mejorar la modularidad y permitir una configuración más flexible de los objetos del juego.

> La función update() contiene lógica para el movimiento de objetos, detección de colisiones y actualización de puntuaciones,
  lo cual puede ser complejo y difícil de mantener. Podría refactorizarse separando la lógica en funciones más pequeñas y modulares,
  como funciones para el movimiento de la pelota, las paletas y la detección de colisiones.

> La lógica para renderizar el texto de puntuación se repite para ambos jugadores en la función render().
  Puede refactorizarse para utilizar una función genérica que renderice el texto de puntuación para cualquier
  jugador, evitando la repetición de código.

> Las estructuras game_object y las variables globales podrían encapsularse mejor dentro de una estructura 
  principal del juego para mejorar el encapsulamiento y la abstracción. La utilización de variables globales 
  podría reducirse en favor de pasar referencias locales a funciones cuando sea posible.

> El ciclo principal del juego en la función main() podría modularizarse más claramente, separando la lógica
  de manejo de eventos, actualización de estado y renderizado en funciones distintas.
 
2. ¿Cuáles fueron los desafíos más significativos de la sesión y cómo los superé?

> Lo mas dificil de esta sesion fue la Re-lectura que le hize al codigo de Pong que tenia
  y dado que la Planificacion para el refactoring requiere hacer ajustes a la bibliotecas SDL,
  los jugadores, fisicas y la sincronizacion del juego.

3. Basado en el trabajo de la sesión, ¿Qué aprendí o qué conclusión saco o cuál es la síntesis?

> Refactorización centrada en mejorar la modularidad, reducir la duplicación de código,
  abstraer la lógica compleja en funciones más pequeñas y hacer que se entienda mejor el codigo.

4. ¿Cuáles son los pasos siguientes para continuar avanzando en el proyecto?

> Continuar con la planeación y ver que puedo hacer con el codigo.

### Sesión 3

1. ¿Cuál será el propósito de la sesión de hoy?

> Intentar en hacer una prueba de Refactoring al codigo de Pong que tengo.

> 
 
2. ¿Cuáles fueron los desafíos más significativos de la sesión y cómo los superé?

> Escribe aquí

3. Basado en el trabajo de la sesión, ¿Qué aprendí o qué conclusión saco o cuál es la síntesis?

> Escribe aquí

4. ¿Cuáles son los pasos siguientes para continuar avanzando en el proyecto?

> Escribe aquí
