# Bitácora de aprendizaje
## SEMANA 6

### Sesión 1

#### Micro-sesión 1: Apertura

Empezaremos con el el desarrollo de la unidad 2, nos dijo que teniamos que ser mas dedicados
con el desarrollo de los programas o codigos. A tal punto que recomienda que hagamos el procesos
de la programacion del codigo. Basicamente haremos Pong el videojuego en assembler aun.

Tambien nos recomendo el uso del lenguaje de programación C, no C++,
Usa la biblioteca SDL2, Usa Visual Studio y el sistema operativo windows
Mantén bajo control de versión tu programa.

#### Micro-sesión 2 

Tal cual el reto de esta unidad es recrear el mitico videojuego Pong
para su implementación del juego la haremos en sentido vertical.

![image](https://github.com/jfUPB/bitacorassc2024-10-Lolman6542/assets/127360762/7d0cc855-27e3-41a7-aeec-d3460992b078)

De lo que tengo entendido es que este principio de la unidad 2 
o al menos en la primera semana es entender o investigar los
temas que trataremos para hacer el programa.

Tambien esta el curso gratuito de Udemy para desarrollar las primeras
fases de la actividad Reto como tal y basicamente esta permitedo el uso 
y manejo de cualquier programas desarrollo y tutoriales como en Youtube 
otras paginas de terceros o el mismo uso de las inteligencias artificiales
dado que el espera que podamos entender y explicar el tema como nosotros podamos.

#### Micro-sesión 3 

Tambien hizo menciones de una pagina que el mismo profesor construyo para 
el desarrollo de las actividades de lenguage C:

![image](https://github.com/jfUPB/bitacorassc2024-10-Lolman6542/assets/127360762/dc46efd2-b172-4e4f-a4c7-f785ae8e14b2)

Para aquellos que necesiten mas ayuda o necesiten de otro medio que no sean 
de las misma I.A , aclaro el profesor de que el codigo se puede obtener por
internet o algun medio el de todas formas necesitaran que ALMENOS uno pueda
tratar de explicar en que funciones o propiedades o lineas de codigos hace
para que funcionen el programa tal cual.

#### Micro-sesión 4: Cierre

Parece divertido con se podra llegar hacer con la recreácion de Pong,
espero que pueda llegar hacer esto y entragar algo decente, pero
ando con la mente algo ofuscando aun tratando de entender el lenguaje 
Assembler y llegar ha intentar acabar la actividad Reto final, 
para hace su documentacion misma, porque la documentacion de cosas
o programas en CPUEmulator es muy poca, demas que con los tutoriales
Udemy.

### Sesión 2

#### Micro-sesión 1: Apertura

Desafortunadamente me perdi de esta clase debido a que andaba con muchas tos,
gripa y dolor de cabeza. De lo que me lograron contar mis compañeros y profesor
es que estubieron desarrollando y resolviendo dudas sobre las etapas de desarrollo de
la guia, entonces seria buena idea comenzar a cuestionar un poquito y ver los puntos guias.
Mas que todo en la parte de experimentación.

#### Micro-sesión 2: Desarrollo

¿Por qué utilizaremos en esta parte del curso el lenguaje C?

Es uno de los lenguajes más utilizados actualmente en sistemas operativos 
como Linux y programación de sistemas embebidos (aquellos que hacen una
tarea o mas en tiempo real, en una unidad de microprocesadores).

Caracterissticas:

- Pocas palabras clave, por lo cual es fácil de aprender.

- Permite crear datos compuestos como estructuras de datos y uniones.

- Permite variables que almacenan la dirección de otra variable.

- Tiene una biblioteca estándar externa.

- Los programa se compilan a código nativo por tanto, la ejecución de los 
  programas es rápida, siempre y cuando estén bien escritos.

- Su flexibiladad al programar, esto va a aportar una absoluta 
  libertad para el programador informático.

El lenguaje de programación C es muy eficiente y ofrece la posibilidad de manejar todos 
los aspectos de las instrucciones del CPU. Su código ofrece una estructura clara y, por tanto,
facilita la creación de aplicaciones de una forma rápida y potente.
Asimismo, al contar con un número limitado de palabras clave su aprendizaje es más rápido.
C optimiza al máximo la memoria de la computadora y predispone los datos estructurados.

Deje un enlace que remarca su 50 aniversario:
https://immune.institute/blog/lenguaje-de-programacion-c/#:~:text=El%20lenguaje%20de%20programaci%C3%B3n%20C%20es%20muy%20eficiente%20y%20ofrece,una%20forma%20r%C3%A1pida%20y%20potente.

#### Micro-sesión 3: Desarrollo

![image](https://github.com/jfUPB/bitacorassc2024-10-Lolman6542/assets/127360762/e6518ee9-105a-44dd-99f9-048e38c2b581)

En uno de los enlances que se encuentrant en la pagina guia se hace mencion a una linea de 
tiempo del cual se pregunta del ¿Por qué tantos lenguajes de programacion? 
Para sorpresa de algunos esto es asi dado que es por mera elección de los mismo programadores
dado que su forma y estilo de trabajo se ve reflejado en el desarrollo de codigo
en el lenguaje de su elección.

![image](https://github.com/jfUPB/bitacorassc2024-10-Lolman6542/assets/127360762/b0f1589a-a2b6-4f80-9e37-a2708d061042)

Se puede apreciar en la imagen anterior en como los lenguajes de progrmas han ido
evolucionando y cambiando por el pasar de los años, a tal punto de que algunos dejan de 
existir y otros nacen de un lenguaje que a lo mejor no tengan nada que ver o almenos
no esten relacionados del todos, como sucesores directos o espirituales en algunos casos.
Los lenguages que mas han estado en el mercado han sido el C , C++ , Java-Script, C#

#### Micro-sesión 4: Cierre

Como tal los lenguajes de programación en su gran parte fueron hechos 
como proyectos personales o tesis de trabajo para la universidad que a 
lo largo del tiempo han sido utiles para el desarrollo y mantenimiento de
varios de aplicaciones o creación de varios softwares.
Puede no se le tome tanta importancia, pero es hecho de que el
futuro de la humanidad sigue estando en el avance de las tecnologias o 
el desarrollo de las revoluciones industriales.


### Sesión 3

#### Micro-sesión 1: Apertura

Para esta sesióm Juan Franco resumio y nos presento la forma de dejar listo el 
visual studio y descargar la bibliotecas SDL2.

#### Micro-sesión 2: 

Primero revisamos las partes que debemos tener descargadas en visual studio la cual 
necesitamos una extension llamada "Desktop development with C++"

![image](https://github.com/jfUPB/bitacorassc2024-10-Lolman6542/assets/127360762/6bca18c4-4713-4c2c-9e17-9afd9a21cf3c)

Luego descargamos el SDL2 y pasamos el archivo extraido a nuestro Disco Local (C:)**

![image](https://github.com/jfUPB/bitacorassc2024-10-Lolman6542/assets/127360762/56b30a55-384e-45d3-aeb8-4f5f353b0b3f)

Arrastramos la carpeta extraida 

![image](https://github.com/jfUPB/bitacorassc2024-10-Lolman6542/assets/127360762/b6310fda-92ba-41f4-8640-2b6a0e99f5dc)

#### Micro-sesión 3:

Abrimos Visual Studio 2022, creamos un proyecto vacio en C++, cambiamos la extension 
por una C. Luego de eso adicionamos los archivos descargados de la biblioteca SDL2 para que
funcione correctamente.

![image](https://github.com/jfUPB/bitacorassc2024-10-Lolman6542/assets/127360762/58e8962e-2e3a-43ed-97cb-d83e9a5ae904)

Agregamos dependencias a las siguientes librerias:

![image](https://github.com/jfUPB/bitacorassc2024-10-Lolman6542/assets/127360762/3f76ecff-5252-4d74-bb7b-19acdd2c27cc)

Ya esta todo instalado tal y como pide la guia.

#### Micro-sesión 4:

Ya por ultimo nos  encargaremos de realizar la actividad que nos propone la actividad de las guias SDL2
para comprobar de que si este funcionando

![image](https://github.com/jfUPB/bitacorassc2024-10-Lolman6542/assets/127360762/05f079fa-17b1-4058-95eb-3261d0c59074)

Ahora mismo me estoy encontrando con un error, del cual conciste en que 
no se esta detectando SDL2.lib

#### Micro-sesión 5: Cierre

De momento no se como solucionar este problema dado que el día que 
es el dia en como se instalaba las librerias de SDL2. Ahora mismo 
estoy dependiendo de unos pantallazos que uno de mis compañeros de 
clase me llego a pasar. De momento tendre que seguir leyendo la guia 
y ver que puedo hacer de mi parte.


## SEMANA 7

### Sesión 1

#### Micro-sesión 1: Apertura

NOTA: Debo terminar la sesión 3 - día autonomo para seguir continuando con la siguiente...

El profesor empezó a trabajar en el programa visual studio, estaba hablando sobre los temas
pasados y empezo hablar sobre depuradores. Empezamos a escribir el siguiente codigo:

 ``` c
#Incluide <stdio.h>
#include <SDL.h>

void fuctionSwap(int *p1, int *p2) {
int tmp = *p1;
*p1 = p2;
*p2 = tmp;
}

int main(int argc, char* argcv[]) {
SDL_Init(SDL_INIT_EVERYTHING);
printf("Hello IDED\n");

int a = 10;
int b = 20;

printf("a:%d - b: %d\n",a,b);
functionSwap(&a, &b);
printf("a:%d - b; %d\n", a, b);

return 0;
}
 ```

#### Micro-sesión 2:

Ahora de lo que tenemos entendido es que escribimos que los depuradores esta guardando
direcciones de las siguientes variables al usar este codigo:

 ``` c
void fuctionSwap(int *p1, int *p2) {
int tmp = p1;
p1 = p2;
p2 = tmp;
}
 ```

Con este codigo guardo los referentes de los objetos:

 ``` c
Class Myclass {
}

MyClass miclass1 = new Myclass();
MyClass miclass2 = new Myclass();
 ```

#### Micro-sesión 3:

Un puntero es una variable que almacena la dirección de memoria de un objeto.
Los punteros se usan ampliamente en C y C++ para tres propósitos principales:
para asignar nuevos objetos en el montón, para pasar funciones a otras funciones.

#### Micro-sesión 4: Cierre

Como conclusion el depurador nos ayuda a encontrar los errores paso a paso
y podamos de esta forma llevar un metodo mas ordenado y eficiente para encontrar errores.

### Sesión 2

#### Micro-sesión 1: Apertura

Hoy nos dedicamos a trabajar en una activida guia/tutorial que nos enseñan a
trabajar paso a paso con SLD2 Y enteder que es lo que ocurre. Y seguir intentando
en solucionar mi problema con los directorios.

#### Micro-sesión 2:

Parece que ya logre solucionar mi error, resulto que me faltaba otra
lineas de directorios por especificar, ademas junto a este nuevo error
que me aparece. Me pide que instalae SDL2.dll. Lo que hara es copiar y pegar
en el directorio raiz de mi codigo. 

![image](https://github.com/jfUPB/bitacorassc2024-10-Lolman6542/assets/127360762/21ebe16d-0b87-4fae-979a-99f23764d245)

Ya ahora no me esta tirando ningun error de la y el codigo esta funcionando 
como deberia.

![image](https://github.com/jfUPB/bitacorassc2024-10-Lolman6542/assets/127360762/8abcde35-bf84-4df6-9e67-e88664cc4888)

Continuando con la guia de SDL2, nos encontraremos con un codigo que creara una ventana

``` c
#include <stdio.h>
#include <SDL.h>

#define TRUE 1
#define FALSE 0
#define WINDOW_WIDTH 800
#define WINDOW_HEIGHT 600

SDL_Window* window = NULL;


int init_window(void){

    if (SDL_Init(SDL_INIT_EVERYTHING) != 0) {
        printf("Error SDL_Init\n");
        return FALSE;
    }

    window = SDL_CreateWindow(
        "My first Window",
        SDL_WINDOWPOS_CENTERED,
        SDL_WINDOWPOS_CENTERED,
        WINDOW_WIDTH,
        WINDOW_HEIGHT,
        SDL_WINDOW_BORDERLESS);
    if (window == NULL) {
        printf("Error SDL_CreateWindow\n");
        return FALSE;
    }
    return TRUE;
}


int main(int argc, char* argv[]) {
    init_window();
    while (TRUE) {
    }
    return 0;
}
```
Lo que ocurre con es codigo es que tiene una funcion main
"While (TRUE) {}", por lo cual el programa estara en un 
bucle infinito. Una pantalla en negro.

![image](https://github.com/jfUPB/bitacorassc2024-10-Lolman6542/assets/127360762/7a52b31b-0cbf-4e94-8450-4b68b64ec51d)

Al borrar la linea anteriormente mencionando
el progrma no abre.

![image](https://github.com/jfUPB/bitacorassc2024-10-Lolman6542/assets/127360762/57d63c5d-0ca8-4fee-ba01-78cf17f7c081)

El punto de entrada en un programa en C es la función main(). La línea #include <stdio.h> 
es una directiva de preprocesador que incluye el contenido del archivo de encabezado stdio.
h en tu programa, permitiendo el uso de funciones de entrada y salida estándar,
como printf() y scanf(), entre otras.

#### Micro-sesión 3:

Nos dedicamos a resolver la prenguta 5 que conciste en pintar la ventana, al
hacerlo con el siguiente codigo.

![image](https://github.com/jfUPB/bitacorassc2024-10-Lolman6542/assets/127360762/87247df1-58cb-4fb4-93e4-29987d40ba01)

Este codigo mostrara los drivers dedicados para creara lo visto en la
funcion dibujar. (El de arriba)

![image](https://github.com/jfUPB/bitacorassc2024-10-Lolman6542/assets/127360762/b1867339-226b-4e1b-be0e-166733770b64)

Con este otro se le puede preguntar a SDL que drivers elegio

![image](https://github.com/jfUPB/bitacorassc2024-10-Lolman6542/assets/127360762/3574d66e-d3c5-4c3c-9bdc-4fec6d722941)

Tambien para que funcione hay que declararlo en la variable global.
Por lo general las variantes Globales son necesarias para que la CPU
puede encontrar dichas variables y se ahorren el tiempo en usarlas,
aumentando su desempeño en la ejecucion de codigos.

#### Micro-sesión 4: Cierre

Tambien nos pusimos a ver un poco de lo que es el GameLoop, pero como 
tal el profesor nos pidio que hablasemos en como reproducir el juego Pong,
del cual demostro e hizo una serie de ajustes en las variables, para que el
movimiento de las fisicas del juego, no dependiencen de la tasa de cuadros por
segundo. Empezar a ver los articulos sobre de GameLoop.

### Sesión 3

#### Micro-sesión 1: Apertura

Empezare a leer el concepto de Gameloop que el profesor nos compartio atraves del
enlace que habia en la pagina Actividad 6 y ver si se empieza a Experimentar con el
mismo codigo que ha puesto el profesor.

#### Micro-sesión 2: 

Para empezar con la guia, el articulo menciona que en un principios los codigos
basicamente funcionaba solo una vez; montabamos el codigo, presionabamos un
boton, esperabamos y obteniamos resultados tal cual como una tarjeta perforada.
Por lo general se hacia muy lento el tener que dejar el programa corriendo y esperar
unas horas para obtener los resultados de los Bugs y errores que tenian.
Necesitaban Feedback de Inmediatos, entonces nacieron los progrmas interactivos

![image](https://github.com/jfUPB/bitacorassc2024-10-Lolman6542/assets/127360762/26bcc5ef-a3be-4175-9207-18b4b5159edc)

Podias incluso obtener una coversacion en vivo con el programa, esperaba 
el comando a ingresar y te respondia de inmideato, asi sucesivamente.
Se quedaba haciendo nada mientras espera tu respuesta.

Tambien se encuentra los Event Loops de los cuales conciste en la espera e 
ingresos de botones/clicks que el jugador oprime, pero ese es el problema
no ocurrira nada hasta que el jugador no ingrese otro boton
Del cual este es uno de los elementos mas importantes del GameLoop;
que procesa el comando del usuario, pero no lo espera. El bucle 
siempre se mantiene en constacia.

Dragon Lair (Arcade):

![image](https://github.com/jfUPB/bitacorassc2024-10-Lolman6542/assets/127360762/f74b6c7f-4945-4575-81cb-e27f7814cd55)


```c

while (true)
{
  processInput();
  update();
  render();
}

```
El processInput se encarga de manejar el ultimo comando
que el jugador coloco.
Update matiene el juego en movimiento en un paso, encargandose
de I.A y la fisicas de juego activas (Incluso en ese orden)
Render muestra o dibuja lo que esta ocurriendo en pantalla.


#### Micro-sesión 3: 

Un caso interesante con lo que ocurre con los manejos de las 
velocidades en los Videojuegos, y es que al manejarse/completarse
tasas tan altas en los ciclos de los juegos, se obtendra una tasa
de cuadros mucho mayor a la deseado. En epocas de antaño, como en
la generación de la NES o Apple IIe se sabia lo que se podia y debian
de hacer al programar para la CPU de dicha consola.

Si en aquel entonces se porteaba un juego a una maquina superior o
inferior, era muy probable que las fisicas del juego se enloqueciecen
debio a que el manejo de codigos se programo de manera exacta para consola.
Lo que se busca con al programar en ciertos Hardwares es que 
ande a la velocidad o a FPS constante en dichas maquinas, que
por lo general es recomendado hacerlo con las especificaciones
minimas para que pueda correr.

BattleToads (NES):

![image](https://github.com/jfUPB/bitacorassc2024-10-Lolman6542/assets/127360762/34d3c831-eb5d-4414-bce9-acd63b549762)
 
En si el GameLoop sigue actualizando el juego sin ninguana restriccion 
o procesa el comando del usuario sin bloqueos, actualiza el estado del
juego y redeneriza 0 dibuja imagenes del juego.
Tambien hay que tener cuidado en no excederce en las velocidades con el
anterior codigo propuesto, entonces lo controlaremos de la siguiente forma.

#### Micro-sesión 4: 


```c
while (true)
{
  double start = getCurrentTime();
  processInput();
  update();
  render();

  sleep(start + MS_PER_FRAME - getCurrentTime());
}
```
sleep() se asegura que el juego no ande tan rapido cuando este
ejecutando los frames. Si emepieza andar lento el juego, lo recomendable
seria cortar los elementos graficos o quitar otros patrones de intelegencia
para la maquina.

Podriamos hacer lo siguiente: 
El tiempo del juego avanza por cietra actualizacion a cierta cantidad.
Y toma cierta cantidad de tiempo real para procesarlo. Si en lo ultimo
toma mas tiempo que hacer lo primero, el juego le costara hacer grandez avances
o moverse, abarcando aun mas el tiempo real costandole aun mas en hacer siguiente pasos.
Llaman a esto varaible o fluid en el paso del tiempo:

```c
double lastTime = getCurrentTime();
while (true)
{
  double current = getCurrentTime();
  double elapsed = current - lastTime;
  processInput();
  update(elapsed);
  render();
  lastTime = current;
}
``` 
Cada cuadro determina cuanto tiempo real ha pasado desde la 
ultima actualizacion. Esto nos colabaro tanto maquinas viejas
para que ande a la tasa de cuadros deseada y para las maquinas nuevas
anda aun mejor de lo que se puede. Pero esto podria otro problema
mas, dado que se podrian poner en competencia dos computadores
totalmente distintos otorga ventajas a las computadoras mas potentes.

#### Micro-sesión 5: Cierre 

El Game Loop es extremadamente importante en el desarrollo de juegos, 
ya que es la estructura fundamental que permite que el juego funcione 
correctamente y se ejecute de manera fluida. Otorgandonos el renderizado,
, interactividad, actualizacion del estado, y optimizaciones.


## SEMANA 8

### Sesión 1

#### Micro-sesión 1: Apertura

Empezaremos con el uso de curso guia de Udemy para empezar el 
desarrollo de nuestro videojuego. Y mas que eso al principo hablan sobre el
uso de los motores graficos y definir GameLoops para que el entorno del desarrollo 
sea mas comodo de lo habitual o almenos tener una idea en como trabajar con dichos motores.
Ademas del Udo del lenguaje C y SDL en nuestro entorno de trabajo.

![image](https://github.com/jfUPB/bitacorassc2024-10-Lolman6542/assets/127360762/d8f886ec-a015-4e94-8186-5de6d0d8f533)

#### Micro-sesión 2: 

Antes de empezar con la guia de trabajo o mas bien el proceso para organizar las Libreias SDL segun el 
sistema Operativo, se me habia hecho tres preguntas.

Una de ellas era ver ¿Cual es mi motor de Videojuegos favorito?
Seria MT Framework y versiones posteriores que usaron.

![Mtframework-logo](https://github.com/jfUPB/bitacorassc2024-10-Lolman6542/assets/127360762/5bf5b17c-d788-42ac-84c0-c4f852b82aac)

Una de la razones por las que me gusta el motor, es debido a lo facil que le resultaba a los desarrolladores
en usar debido a que su arquictecura era similar a la de un PC, haciend que los ports de PC a consolas
como la Xbox360 fuesen facil de hacer, junto a la gran variedad de elemento graficos que se pueden aplicar.

Dead Risng 1 el primer juego de Capcom en usar este motor:

![image](https://github.com/jfUPB/bitacorassc2024-10-Lolman6542/assets/127360762/777abf16-a609-4c6b-9354-b2119cd616b0)


Monster Hunter World, es de los ultimos juegos en usarlo:

![image](https://github.com/jfUPB/bitacorassc2024-10-Lolman6542/assets/127360762/d012a3c9-2cbe-4a50-8d35-8c3013d63c2c)

Desconosco la veces que el motor llama por la funcion de Update, pero
creo que es alrededor de los 10 ms para llamar un cuadro (Imagen de referente, cuando hay enemigos y mucha accion baja a los 30ms)

![image](https://github.com/jfUPB/bitacorassc2024-10-Lolman6542/assets/127360762/e1b512b1-1ff6-4066-b068-a2842b8b4b24)

Consolas modernas 10ms y consolas antiguas 30-35

en la guia habia un tutorial para instalar las herramientas de trabajo para el proyecto pero ya se habia hecho.

#### Micro-sesión 3: 

Estube haciendo un pequeño Quiz de 2 preguntas acerca de SDL y de las dos funciones Draw y Update. 
Ademas se puede apreciar en como se compila con GCC y un makefile, el cual permite ejecutar el
programa deseado con cierto comandos.

#### Micro-sesión 4: Cierre

La creacion de los videojuegos pueden variar segun su proceso de desarrallo
dado que estos pueden tomar bastantes años debido a lo complejo que pueden llegar
a ser los motores de los videojuegos, es por ende importante ver lo que se puede 
llegar hacer y lo que no, para seguir invirtiendo en algo mas.

### Sesión 2

#### Micro-sesión 1: Apertura

Siguiendo con la actividad guia de la pagina oficial de Sistemas computacionales
resulta que es similar a la actividad guia de Udemy, entonces mejor me quedo con la 
pagina oficial del curso dado que esta en español.

#### Micro-sesión 2: 

En en la siguiente imagen se puede encontrar un cuadro de codigo que trata sobre
la creacion del rectangulo que el jugador usara, aun no podra mostrar el cuadro.

![image](https://github.com/jfUPB/bitacorassc2024-10-Lolman6542/assets/127360762/d1a071fe-b172-4238-9ff0-25466089315b)

Aca esta hecho:

![image](https://github.com/jfUPB/bitacorassc2024-10-Lolman6542/assets/127360762/a8f12c13-56ed-45e3-b96d-999e5e51c187)


Tambien esta el codigo o una funcion para posicionar la ubicacion de la 
bola por donde mas o menos podria arrancar. En resumen este codigo 
es similar a un plano cartesiano en donde el valor de X es donde 
se posiciona horizontalmente, el Y verticalmente. Como se muestra en la
pantalla el valor de la bolar al arrancar en 0,0 estaria en la esquina superior izquierda.

```c
void DrawCircle(SDL_Renderer* renderer, int cx, int cy, int radius) {
  for (int y = -radius; y <= radius; y++) {
    for (int x = -radius; x <= radius; x++) {
      if (x * x + y * y <= radius * radius) {
        SDL_RenderDrawPoint(renderer, cx + x, cy + y);
      }
    }
  }
}

ACTUALIZAR RENDER:

void render(void) {
  SDL_Rect rect;
  rect.x = 250; // Posición x del rectángulo
  rect.y = 150; // Posición y del rectángulo
  rect.w = 200; // Ancho del rectángulo
  rect.h = 100; // Alto del rectángulo

  // Limpia el "lienzo" en este frame (?)
  SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255); // Color de fondo: negro
  SDL_RenderClear(renderer);

  // Dibuja el rectángulo, pero aún no lo muestra
  SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255); // Color del rectángulo: rojo
  SDL_RenderFillRect(renderer, &rect);

  // Dibuja el círculo
  SDL_SetRenderDrawColor(renderer, 255, 255, 0, 255); // Amarillo
  DrawCircle(renderer, 400, 360, 100); // Dibuja un círculo en (320, 240) con radio 100.

  // Actualiza el lienzo
  SDL_RenderPresent(renderer);
}


```

![image](https://github.com/jfUPB/bitacorassc2024-10-Lolman6542/assets/127360762/09188f9a-73a9-441d-ae5a-82eacefc92e6)


#### Micro-sesión 3:

Para el siguiente ejercicio pintaremos los lienzo para ubicar las cosas en el SDL2
Junto con el tema de double Buffering, entonces hize lo que me pidio lo que la guia me dijo que hiziera y
eso era borrar la linea deseada. Al hacer esto la imagen del circulo y rectangulo desaparecieron.

![image](https://github.com/jfUPB/bitacorassc2024-10-Lolman6542/assets/127360762/1a78121d-39d3-487a-8413-577370ad13b5)

En teoria, el double buffering funciona al dos Buffers o espacio de memoria temporal, que 
no seran referaenciado directamente en el array o fila, se llamara a otras dos funcciones
que seran dibujadas en vez de las anteriorios mencionadas. Cuando se dibuje, se llama
este sera referenciado por next y cuando se necesiten de otros pixeles
se hara atravez de otro buffer llamado current. Al finalizar se usa el Swap
para que este cambie de escene al finalizar la imagen, llamando las dos funciones 
de arriba, logrando que los drivers al finalizar un render, basicamente ya tenga
el otro hecho o listo para ser visto.

#### Micro-sesión 4: Cierre

Me parecio interesante que el problema del tearing se condidere un Bug,
dado en que mis conocimientos acerca de este tema era algo mas "esporadico"
(la verdad ni se como decirlo mejor) y que propiamente era V-sync el que 
solucionaba el problema, dado que el era el encargado de que actulizace la
la tasa de imagenes al tiempo concreto segun la tasa de refresco del
monitor sin exceder. Propiamente el V-sync no es un limitador de Fotogramas
pero ayuda a mantener al margen actual y que el problema del tearing se
puede resolver con lineas de codigos.

### Sesión 3

#### Micro-sesión 1: Apertura

Me encaargare de realizar el trabajo guia punto 12, que es en si el video 18 del
la clase de Udemy, probar el codigo y ver si lo puedo modificar a a tal grado de 
que cumpla los requisitos que me pide la unidad 2.
